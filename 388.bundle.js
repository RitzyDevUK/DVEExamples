(self.webpackChunkdivinecraft=self.webpackChunkdivinecraft||[]).push([[388],{29835:function(t){t.exports=function(){"use strict";return t.importState=function(e){var s=new t;return s.importState(e),s},t;function t(){return function(t){var e=0,s=0,i=0,r=1;0==t.length&&(t=[+new Date]);var o=function(){var t=4022871197,e=function(e){e=e.toString();for(var s=0;s<e.length;s++){var i=.02519603282416938*(t+=e.charCodeAt(s));i-=t=i>>>0,t=(i*=t)>>>0,t+=4294967296*(i-=t)}return 2.3283064365386963e-10*(t>>>0)};return e.version="Mash 0.9",e}();e=o(" "),s=o(" "),i=o(" ");for(var n=0;n<t.length;n++)(e-=o(t[n]))<0&&(e+=1),(s-=o(t[n]))<0&&(s+=1),(i-=o(t[n]))<0&&(i+=1);o=null;var a=function(){var t=2091639*e+2.3283064365386963e-10*r;return e=s,s=i,i=t-(r=0|t)};return a.next=a,a.uint32=function(){return 4294967296*a()},a.fract53=function(){return a()+11102230246251565e-32*(2097152*a()|0)},a.version="Alea 0.9",a.args=t,a.exportState=function(){return[e,s,i,r]},a.importState=function(t){e=+t[0]||0,s=+t[1]||0,i=+t[2]||0,r=+t[3]||0},a}(Array.prototype.slice.call(arguments))}}()},35223:(t,e,s)=>{"use strict";s.d(e,{f:()=>a});var i=s(11628),r=s(31139),o=s(56956),n=s(80917);class a{static nodes=i.W;static setUseSharedMemory(t){r.F.setUseSharedMemory(t)}static bufferToObject(t,e=0,s=0){return r.F.toObject(t,e,s)}static objectToBuffer(t){return o.o.toBuffer(t)}static objectToTypedNodes(t){return o.o.tokTypedNodes(t)}static typedNodeToBuffer(t){return n.h.toBuffer(t)}static bufferToTypedNodes(t,e=0,s=0){return r.F.toTypedNodes(t,e,s)}}},31139:(t,e,s)=>{"use strict";s.d(e,{F:()=>h});var i=s(14494),r=s(95873),o=s(45466),n=s(25424),a=s(95541);class h{static _mode="object";static _sharedMemory=!1;static _cobj={};static _parents=[];static _objArray=[];static _name="";static _length=0;static _objCount=0;static _inOject=!1;static _newTypedNode(t,e,s=0){return new o.R(t,e,s)}static _assign(t){"object"==this._mode||"json"==this._mode?Array.isArray(this._cobj)?this._cobj.push(t):this._cobj[this._name]=t:Array.isArray(this._cobj.value)?this._cobj.value.push(t):this._cobj.value[this._name]=t}static markFunctions={[i.A.Name]:(t,e)=>{this._name="";const s=Number(n.n[r.QI.Uint8](t,e+1));for(let i=e+=2*r.bI.Uint8;i<e+s;i++)this._name+=String.fromCharCode(n.n[r.QI.Uint8](t,i));return e+s*r.bI.Uint8},[i.A.Object]:(t,e)=>{let s;return s="object"==this._mode?{}:this._newTypedNode(i.A.Object,{}),0!=this._objCount&&(this._assign(s),this._parents.push(this._cobj)),this._objCount++,this._cobj=s,r.bI.Uint8+e},[i.A.ObjectEnd]:(t,e)=>(this._parents.length>0&&(this._cobj=this._parents.pop()),r.bI.Uint8+e),[i.A.Array]:(t,e)=>{let s;return s="object"==this._mode?[]:this._newTypedNode(i.A.Array,[]),0!=this._objCount&&(this._assign(s),this._parents.push(this._cobj)),this._objCount++,this._cobj=s,r.bI.Uint8+e},[i.A.ArrayEnd]:(t,e)=>(this._parents.length>0&&(this._cobj=this._parents.pop()),r.bI.Uint8+e),[i.A.Boolean]:(t,e)=>{const s=n.n[r.QI.Uint8](t,e+1);return"type-node"!=this._mode?this._assign(!s):this._assign(this._newTypedNode(i.A.Boolean,!s)),r.bI.Uint8+r.bI.Int8+e},[i.A.Undefined]:(t,e)=>("type-node"!=this._mode?this._assign(void 0):this._assign(this._newTypedNode(i.A.Undefined,void 0)),r.bI.Uint8+e),[i.A.Int8]:(t,e)=>{const s=n.n[r.QI.Int8](t,e+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(i.A.Int8,s)),r.bI.Uint8+r.bI.Int8+e},[i.A.Uint8]:(t,e)=>{const s=n.n[r.QI.Uint8](t,e+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(i.A.Uint8,s)),r.bI.Uint8+r.bI.Uint8+e},[i.A.Uint8Clamped]:(t,e)=>{const s=n.n[r.QI.Uint8](t,e+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(i.A.Uint8,s)),r.bI.Uint8+r.bI.Uint8+e},[i.A.Int16]:(t,e)=>{const s=n.n[r.QI.Int16](t,e+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(i.A.Int16,s)),r.bI.Uint8+r.bI.Int16+e},[i.A.Uint16]:(t,e)=>{const s=n.n[r.QI.Uint16](t,e+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(i.A.Uint16,s)),r.bI.Uint8+r.bI.Uint16+e},[i.A.Float32]:(t,e)=>{const s=n.n[r.QI.Float32](t,e+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(i.A.Float32,s)),r.bI.Uint8+r.bI.Float32+e},[i.A.Int32]:(t,e)=>{const s=n.n[r.QI.Int32](t,e+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(i.A.Int32,s)),r.bI.Uint8+r.bI.Int32+e},[i.A.Uint32]:(t,e)=>{const s=n.n[r.QI.Uint32](t,e+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(i.A.Uint32,s)),r.bI.Uint8+r.bI.Uint8+r.bI.Uint32+e+1},[i.A.Float64]:(t,e)=>{const s=n.n[r.QI.Float64](t,e+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(i.A.Float64,s)),r.bI.Uint8+r.bI.Float64+e},[i.A.BigInt]:(t,e)=>{const s=n.n[r.QI.BigInt](t,e+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(i.A.BigInt,s)),r.bI.Uint8+r.bI.BigInt+e},[i.A.BigUint]:(t,e)=>{const s=n.n[r.QI.BigUint](t,e+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(i.A.BigUint,s)),r.bI.Uint8+r.bI.BigUint+e},[i.A.String]:(t,e)=>{const s=n.n[r.QI.Uint32](t,e+1);let o="";for(let i=e+=r.bI.Uint32+r.bI.Uint8;i<e+s;i++)o+=String.fromCharCode(n.n[r.QI.Uint8](t,i));return"type-node"!=this._mode?this._assign(o):this._assign(this._newTypedNode(i.A.String,o)),e+s*r.bI.Uint8},[i.A.TypedArray]:(t,e)=>{const s=n.n[r.QI.Uint8](t,e+1);if(void 0===s)throw new Error(`Not a valid type for a typed array ${s}`);const o=n.n[r.QI.Uint32](t,e+2);let h;e+=2*r.bI.Uint8+r.bI.Uint32,h="json"==this._mode?[]:a.I[s](o,this._sharedMemory);const l=n.n[s];for(let i=0;i<o;i++)h[i]=l(t,e),e+=r.Yd[s];return"type-node"!=this._mode?this._assign(h):this._assign(this._newTypedNode(i.A.TypedArray,h,s)),e},[i.A.Blob]:(t,e)=>("type-node"!=this._mode?this._assign(Blob):this._assign(this._newTypedNode(i.A.Blob,void 0)),r.bI.Uint8+e),[i.A.ArrayBuffer]:(t,e)=>{const s=n.n[r.QI.Uint32](t,e+1);e+=r.bI.Uint8+r.bI.Uint32;const o=new Uint8Array(this._sharedMemory?new SharedArrayBuffer(s):new ArrayBuffer(s));for(let i=0;i<s;i++)o[i]=n.n[r.QI.Uint8](t,e),e+=r.QI.Uint8;return"type-node"!=this._mode?this._assign(o.buffer):this._assign(this._newTypedNode(i.A.ArrayBuffer,o.buffer)),e},[i.A.Json]:(t,e)=>{const s=n.n[r.QI.Uint32](t,e+1);let o="";for(let i=e+=r.bI.Float32+r.bI.Uint8;i<e+s;i++)o+=String.fromCharCode(n.n[r.QI.Uint8](t,i));const a=JSON.parse(o);return"type-node"!=this._mode?this._assign(a):this._assign(this._newTypedNode(i.A.Json,a)),e+s*r.bI.Uint8}};static setUseSharedMemory(t){this._sharedMemory=t}static toObject(t,e=0,s=0){let o;this._mode="object",o=0==s?t.byteLength:s;const a=new DataView(t);this._objCount=0;let h=e,l=i.A.Object;for(;h<o;)l=n.n[r.QI.Uint8](a,h),h=this.markFunctions[l](a,h);return this._cobj}static toJSON(t,e=0,s=0){let o;this._mode="json",o=0==s?t.byteLength:s;const a=new DataView(t);this._objCount=0;let h=e,l=i.A.Object;for(;h<o;)l=n.n[r.QI.Uint8](a,h),h=this.markFunctions[l](a,h);return this._cobj}static toTypedNodes(t,e=0,s=0){let o;this._mode="type-node",o=0==s?t.byteLength:s,this._mode="object";const a=new DataView(t);this._objCount=0;let h=e,l=i.A.Object;for(;h<o;)l=n.n[r.QI.Uint8](a,h),h=this.markFunctions[l](a,h);return this._cobj}}},56956:(t,e,s)=>{"use strict";s.d(e,{o:()=>a});var i=s(49031),r=s(45466),o=s(11628),n=s(80917);class a{static _name="";static _traverseObj(t){const e=o.W.object({});for(const s of Object.keys(t)){const i=t[s];this._name=s,i instanceof r.R?e.value[s]=i:ArrayBuffer.isView(i)||i instanceof ArrayBuffer||i instanceof SharedArrayBuffer?e.value[s]=this._addPrimitive(i):i instanceof Blob||"undefined"!=typeof File&&i instanceof File||("object"!=typeof i||Array.isArray(i)?"object"==typeof i&&Array.isArray(i)?e.value[s]=this._traverseArray(i):e.value[s]=this._addPrimitive(i):e.value[s]=this._traverseObj(i))}return e}static _traverseArray(t){const e=o.W.array([]);for(const s of t)s instanceof r.R?e.value.push(s):ArrayBuffer.isView(s)?e.value.push(this._addPrimitive(s)):"object"!=typeof s||Array.isArray(s)?"object"!=typeof s||!Array.isArray(s)||ArrayBuffer.isView(s)?e.value.push(this._addPrimitive(s)):e.value.push(this._traverseArray(s)):e.value.push(this._traverseObj(s));return e}static _addPrimitive(t){if("string"==typeof t)return o.W.string(t);if("number"==typeof t)return o.W.float64(t);if("boolean"==typeof t)return o.W.boolean(t);if(void 0===t)return o.W.undefined();if(t instanceof ArrayBuffer||t instanceof SharedArrayBuffer)return o.W.arrayBuffer(t);if(ArrayBuffer.isView(t)&&i.n.has(t.constructor))return o.W.typedArray(i.n.get(t.constructor),t);if(t instanceof r.R)return t;throw new Error("Unsuppourted type for DBO parser.")}static tokTypedNodes(t){if("object"==typeof t&&!Array.isArray(t)){const e=o.W.object({});return e.value=this._traverseObj(t).value,e}if("object"==typeof t&&Array.isArray(t)){const e=o.W.array([]);return e.value=this._traverseArray(t).value,e}return this._addPrimitive(t)}static toBuffer(t){const e=this.tokTypedNodes(t);return n.h.toBuffer(e)}}},80917:(t,e,s)=>{"use strict";s.d(e,{h:()=>n});var i=s(14494),r=s(95873),o=s(77288);class n{static _proto=[];static _tokenizeString(t){for(let e=0;e<t.length;e++)this._addToken(r.QI.Uint8,t.charCodeAt(e))}static _traverseObj(t){this._addMarker(i.A.Object);for(const e of Object.keys(t.value)){if(e.length>255)throw new Error("An object key cannot be longer then 255 chars.");this._addMarker(i.A.Name),this._addToken(r.QI.Uint8,e.length),this._tokenizeString(e);const s=t.value[e];s.marker!=i.A.Object||ArrayBuffer.isView(s.value)?s.marker!=i.A.Array||ArrayBuffer.isView(s.value)?this._tokenizePrimiives(s):this._traverseArray(s):this._traverseObj(s)}this._addMarker(i.A.ObjectEnd)}static _traverseArray(t){this._addMarker(i.A.Array);const e=t.value;for(const t of e)"object"!=typeof t.value||Array.isArray(t.value)||ArrayBuffer.isView(t.value)?"object"!=typeof t.value||!Array.isArray(t.value)||ArrayBuffer.isView(t.value)?this._tokenizePrimiives(t):this._traverseArray(t):this._traverseObj(t);this._addMarker(i.A.ArrayEnd)}static _tokenizePrimiives(t){if(t.marker!=i.A.String){if("number"==typeof t.value)return this._addMarker(t.marker),void this._addToken(t.numberType,t.value);if("boolean"==typeof t.value)return this._addMarker(t.marker),void this._addToken(r.QI.Uint8,t.value?0:1);if(void 0!==t.value)if(t.marker!=i.A.ArrayBuffer){if(t.marker==i.A.TypedArray){this._addMarker(i.A.TypedArray),this._addToken(r.QI.Uint8,t.listType),this._addToken(r.QI.Uint32,t.value.length);let e=t.value;for(let s=0;s<e.length;s++)this._addToken(t.listType,e[s])}if(t.marker!=i.A.Json);else{let e="";e="object"==typeof t.value?JSON.stringify(t.value):t.value,this._addMarker(i.A.Json),this._addToken(r.QI.Uint32,e.length);for(let t=0;t<e.length;t++)this._addToken(r.QI.Uint8,e.charCodeAt(t))}}else{this._addMarker(i.A.ArrayBuffer);const e=new Uint8Array(t.value);this._addToken(r.QI.Uint32,e.length);for(let t=0;t<e.length;t++)this._addToken(r.QI.Uint8,e[t])}else this._addMarker(i.A.Undefined)}else{this._addMarker(i.A.String),this._addToken(r.QI.Uint32,t.value.length);for(let e=0;e<t.value.length;e++)this._addToken(r.QI.Uint8,t.value.charCodeAt(e))}}static _tokenize(t){t.marker!=i.A.Object||Array.isArray(t.value)||this._traverseObj(t),t.marker==i.A.Array&&Array.isArray(t.value)&&this._traverseArray(t)}static toBuffer(t){this._tokenize(t);const e=Uint8Array.from(this._proto);return this._proto=[],e.buffer}static _addMarker(t){o.d.setValue(r.QI.Uint8,t).addBytes(this._proto)}static _addToken(t,e){o.d.setValue(t,e).addBytes(this._proto)}}},11628:(t,e,s)=>{"use strict";s.d(e,{W:()=>o});var i=s(45466),r=s(14494);class o{static json(t){return new i.R(r.A.Json,t)}static object(t){return new i.R(r.A.Object,t)}static array(t){if(!Array.isArray(t))throw new Error("Data for array must be an array.");return new i.R(r.A.Array,t)}static int8(t){return new i.R(r.A.Int8,t)}static uIint8(t){return new i.R(r.A.Uint8,t)}static int16(t){return new i.R(r.A.Int16,t)}static uint16(t){return new i.R(r.A.Uint16,t)}static uint32(t){return new i.R(r.A.Uint32,t)}static int32(t){return new i.R(r.A.Int32,t)}static float32(t){return new i.R(r.A.Float32,t)}static float64(t){return new i.R(r.A.Float64,t)}static bingInt(t){return new i.R(r.A.BigInt,t)}static bigUint(t){return new i.R(r.A.BigUint,t)}static boolean(t){return new i.R(r.A.Boolean,t)}static undefined(){return new i.R(r.A.Undefined,void 0)}static arrayBuffer(t){return new i.R(r.A.ArrayBuffer,t)}static typedArray(t,e){return new i.R(r.A.TypedArray,ArrayBuffer.isView(e)?e:TypedArrayMap[t].from(e),t)}static string(t){return new i.R(r.A.String,t)}}},42577:(t,e,s)=>{"use strict";s.d(e,{f6:()=>i.f}),s(11628),s(45466);var i=s(35223)},77288:(t,e,s)=>{"use strict";s.d(e,{d:()=>o});var i=s(95873),r=s(96692);class o{static view=new DataView(new ArrayBuffer(8));static count=0;static value=0;static setValue(t,e){return this.value=e,r.v[t](this.view,0,e),this.count=i.Yd[t],this}static addBytes(t){for(let e=0;e<this.count;e++)t.push(this.view.getUint8(e))}}},49031:(t,e,s)=>{"use strict";s.d(e,{Q:()=>r,n:()=>o});var i=s(95873);const r={[i.QI.Int8]:Int8Array,[i.QI.Uint8]:Uint8Array,[i.QI.Uint8Clamped]:Uint8ClampedArray,[i.QI.Int16]:Int16Array,[i.QI.Uint16]:Uint16Array,[i.QI.Float32]:Float32Array,[i.QI.Int32]:Int32Array,[i.QI.Uint32]:Uint32Array,[i.QI.Float64]:Float64Array,[i.QI.BigInt]:BigInt64Array,[i.QI.BigUint]:BigUint64Array},o=new Map([[Int8Array,i.QI.Int8],[Uint8Array,i.QI.Uint8],[Uint8ClampedArray,i.QI.Uint8Clamped],[Int16Array,i.QI.Int16],[Uint16Array,i.QI.Uint16],[Int32Array,i.QI.Int32],[Uint32Array,i.QI.Uint32],[Float32Array,i.QI.Float32],[Float64Array,i.QI.Float64],[BigInt64Array,i.QI.BigInt],[BigUint64Array,i.QI.BigUint]])},54265:(t,e,s)=>{"use strict";s.d(e,{f6:()=>i.f6,gZ:()=>r.gZ,jm:()=>r.jm});var i=s(42577),r=s(10379);s(95873),s(79418)},29458:(t,e,s)=>{"use strict";var i,r;s.d(e,{$f:()=>i,xH:()=>r}),function(t){t.North="north",t.South="south",t.West="west",t.East="east",t.NorthEast="north-east",t.NorthWest="north-west",t.SouthEast="south-east",t.SouthWest="south-west"}(i||(i={})),function(t){t[t.North=0]="North",t[t.NorthEast=Math.PI/4]="NorthEast",t[t.East=Math.PI/2]="East",t[t.SouthEast=3*Math.PI/4]="SouthEast",t[t.South=Math.PI]="South",t[t.SouthWest=5*Math.PI/4]="SouthWest",t[t.West=3*Math.PI/2]="West",t[t.NorthWest=7*Math.PI/4]="NorthWest"}(r||(r={})),i.North,r.North,i.South,r.South,i.West,r.West,i.East,r.East,i.NorthEast,r.NorthEast,i.NorthWest,r.NorthWest,i.SouthEast,r.SouthEast,i.SouthWest,r.SouthWest},30971:(t,e,s)=>{"use strict";s.d(e,{Jd:()=>i.J});var i=s(87823)},69775:(t,e,s)=>{"use strict";function i(t,e,s,i,r,o){return Math.sqrt((i-t)**2+(r-e)**2+(o-s)**2)}s.d(e,{D:()=>i})},94496:(t,e,s)=>{"use strict";function i(t,e,s,i){var r=e-t,o=i-s;return Math.sqrt(r*r+o*o)}s.d(e,{me:()=>i,D7:()=>r.D});var r=s(69775)},38869:(t,e,s)=>{"use strict";s.d(e,{Az:()=>r.A,D7:()=>o.D7,me:()=>o.me,xt:()=>i.x});var i=s(36078),r=s(45741),o=s(94496)},65227:(t,e,s)=>{"use strict";s.d(e,{F:()=>i});class i{_getIndex;_getXYZ;position;bounds;constructor(t,e){this._getIndex=t,this._getXYZ=e,this.position=[0,0,0],this.bounds=[1,1,1]}static GetXZYOrder(){return new i(((t,e)=>t[0]+t[2]*e[0]+t[1]*e[0]*e[2]),((t,e,s)=>{s[1]=Math.floor(t/(e[0]*e[2])),s[2]=Math.floor(t%(e[0]*e[2])/e[0]),s[0]=Math.floor(t%e[0])}))}static GetXYZOrder(){return new i(((t,e)=>t[0]+t[1]*e[0]+t[2]*e[0]*e[1]),((t,e,s)=>{s[2]=Math.floor(t/(e[0]*e[1])),s[1]=Math.floor(t%(e[0]*e[1])/e[0]),s[0]=Math.floor(t%e[0])}))}get size(){return this.bounds[0]*this.bounds[1]*this.bounds[2]}getIndex(t){return this._getIndex(t,this.bounds)}getIndexVec3Array(t){return this.position[0]=t[0],this.position[1]=t[1],this.position[2]=t[2],this._getIndex(this.position,this.bounds)}getIndexXYZ(t,e,s){return this.position[0]=t,this.position[1]=e,this.position[2]=s,this._getIndex(this.position,this.bounds)}getIndexVec3(t){return this.position[0]=t.x,this.position[1]=t.y,this.position[2]=t.z,this._getIndex(this.position,this.bounds)}output=[0,0,0];getXYZ(t){return this._getXYZ(t,this.bounds,this.output),this.output}setBounds(t,e,s){this.bounds[0]=t,this.bounds[1]=e,this.bounds[2]=s}}},34459:(t,e,s)=>{"use strict";s.d(e,{F:()=>i.F});var i=s(65227)},51666:(t,e,s)=>{"use strict";s.d(e,{l:()=>i});class i{static ForEachFromToVec2(t,e,s,i){const r=t[0]<e[0]?s:-s,o=t[1]<e[1]?s:-s;for(let s=t[0];r>0?s<=e[0]:s>=e[0];s+=r)for(let r=t[1];o>0?r<=e[1]:r>=e[1];r+=o)i(s,r)}static*FromToVec2(t,e,s){const i=t[0]<e[0]?s:-s,r=t[1]<e[1]?s:-s;for(let s=t[0];i>0?s<=e[0]:s>=e[0];s+=i)for(let i=t[1];r>0?i<=e[1]:i>=e[1];i+=r)yield{x:s,y:i}}static ForEachFromToVec3(t,e,s,i){const r=t[0]<e[0]?s:-s,o=t[1]<e[1]?s:-s,n=t[2]<e[2]?s:-s;for(let s=t[0];r>0?s<=e[0]:s>=e[0];s+=r)for(let r=t[1];o>0?r<=e[1]:r>=e[1];r+=o)for(let o=t[2];n>0?o<=e[2]:o>=e[2];o+=n)i(s,r,o)}static*FromToVec3(t,e,s){const i=t[0]<e[0]?s:-s,r=t[1]<e[1]?s:-s,o=t[2]<e[2]?s:-s;for(let s=t[0];i>0?s<=e[0]:s>=e[0];s+=i)for(let i=t[1];r>0?i<=e[1]:i>=e[1];i+=r)for(let r=t[2];o>0?r<=e[2]:r>=e[2];r+=o)yield{x:s,y:i,z:r}}}},17770:(t,e,s)=>{"use strict";s.d(e,{F$:()=>i.F,l5:()=>r.l});var i=s(34459),r=s(51666)},99638:(t,e,s)=>{"use strict";s.d(e,{$f:()=>n.$f,Az:()=>i.Az,D7:()=>i.D7,F$:()=>r.F$,Jd:()=>o.Jd,l5:()=>r.l5,me:()=>i.me,xH:()=>n.xH,xt:()=>i.xt});var i=s(38869),r=s(17770),o=s(30971),n=s(29458)},75184:(t,e,s)=>{"use strict";s.d(e,{t:()=>i});const i={getIndex(t,e=Math.random()){if(t.length<=1)return 0;const s=[];let i=0;for(const[e,r]of t)i+=r,s.push(i);const r=e*i|0;let o=0;for(const t of s){if(r<=t)break;o++}return o},getValue(t,e=Math.random()){return t[this.getIndex(t,e)][0]}}},97123:(t,e,s)=>{"use strict";s.d(e,{j:()=>n});var i=s(88224),r=s(81863),o=s(54966);class n{name;index;threadPoolName;static readySet=new Set;get isRemoteReady(){return n.readySet.has(this)}get isPortSet(){return Boolean(this.port)}port=null;_pool=null;constructor(t,e,s="worker",i=null){this.name=t,this.index=e,this.threadPoolName=s,this._pool=i}setPort(t){if(this.port=t,"browser"==i.Q.environment){const e=t;e.onmessage=t=>{if(o.E.isInternal(t.data))return o.E.runInternal(t.data,this,t)},e.onmessageerror=t=>{console.error(`Error occured in from thread ${this.name}`),console.log(t.data),console.log(t)}}if("node"==i.Q.environment){const e=t;e.on("message",(t=>{if(o.E.isInternal(t))return o.E.runInternal(t,this,t)})),e.on("error",(t=>{console.error(`Error occured in from thread ${this.name}`),console.log(t)}))}this.sendMessage([o.E.INTERNAL_CODE,r.g.setReady,[this.name,this.index]])}sendMessage(t,e){if(!this.port)throw new Error(`Cannot send message to thread [${this.name}] port is not set`);this.port.postMessage(t,"browser"==i.Q.environment&&e?e:void 0)}connectToThread(t){const e=new MessageChannel;t.sendMessage([o.E.INTERNAL_CODE,r.g.connectPort,[this.name,this.threadPoolName,e.port1]],[e.port1]),this.sendMessage([o.E.INTERNAL_CODE,r.g.connectPort,[t.name,t.threadPoolName,e.port2]],[e.port2])}waitTillTaskExist(t,e=50){let s=!1;return new Promise((i=>{const r=t=>{if(s)return clearTimeout(n);t?(s=!0,i(!0),clearTimeout(n)):setTimeout(o,e)},o=()=>{this.taskExist(t,r)};let n=setTimeout(o,e)}))}taskExist(t,e){const s=o.E.getPromiseId();o.z.checkTasks[2][0]=t,o.z.checkTasks[2][1]=s,this.sendMessage(o.z.checkTasks),o.E.addPromiseTakss("tasks-check",s,(t=>{e(t)}))}runTask(t,e,s,i){const r=i?o.E.getPromiseId():-1;i&&o.E.addPromiseTakss(t,r,i),o.z.runTask[2][0]=t,o.z.runTask[2][1]=r,o.z.runTask[2][2]=e,this.sendMessage(o.z.runTask,s),o.z.runTask[2][2]=null}runTaskAsync(t,e,s){return new Promise((i=>{this.runTask(t,e,s,(t=>{i(t)}))}))}waitTillReady(){return new Promise(((t,e)=>{const s=setInterval((()=>{this.isPortSet&&(clearInterval(s),t(!0))}),1)}))}destroy(){n.readySet.delete(this),this.port&&"terminate"in this.port&&this.port.terminate()}}},50413:(t,e,s)=>{"use strict";s.d(e,{p:()=>o});var i=s(97123),r=s(88224);class o{name;_totalThreads=0;_currentThread=0;__threads=[];constructor(t){this.name=t}getThreads(){return this.__threads}connectToThread(t){for(const e of this.__threads)e.connectToThread(t)}destroyAll(){for(const t of this.__threads)t.destroy()}isReady(){let t=!0;for(const e of this.__threads)e.isPortSet||(t=!1);return t}waitTillAllAreReady(){return new Promise(((t,e)=>{const s=setInterval((()=>{this.isReady()&&(clearInterval(s),t(!0))}),1)}))}addPort(t){const e=`${this.name}-${this._totalThreads}`,s=new i.j(e,this._totalThreads,this.name,this);r.Q.addThread(s),s.setPort(t),this.__threads.push(s),this._totalThreads++}runTaskForAll(t,e,s){for(let i=0;i<this.__threads.length;i++)this.__threads[i].runTask(t,e,s)}runTask(t,e,s,i,r,o){return"number"!=typeof r?(this._currentThread==o&&this.__handleCount(),this.__threads[this._currentThread].runTask(t,e,s,i),this.__handleCount()):(this.__threads[r].runTask(t,e,s,i),r)}runTaskAsync(t,e,s,i,r){return new Promise((o=>{this.runTask(t,e,s,o,i,r)}))}__handleCount(){let t=this._currentThread;return this._currentThread++,this._currentThread>=this._totalThreads&&(this._currentThread=0),t}}},98899:(t,e,s)=>{"use strict";s.d(e,{c:()=>a});var i=s(25701),r=s(82683);const o=i.QK.createThread("world");class n extends r.Q{static instnace;parent=i.QK.parent;world=o;constructor(){super(),n.instnace=this,this.addThread(this.world),this.addThread(this.parent)}}class a{static environment="browser";static instance;TC=i.QK;threads=new n;constructor(){if(a.instance)return a.instance;a.instance=this}}},54186:(t,e,s)=>{"use strict";s.d(e,{S:()=>a,f:()=>h});var i=s(35238),r=s(62307);class o{buffer;data;constructor(t){return this.buffer=t,this.data=new DataView(ArrayBuffer.isView(t)?t.buffer:t),new Proxy(this,{get:(t,e)=>{if("string"==typeof e&&!isNaN(Number(e))){const s=Number(e);return t.get(s)}return t[e]},set:(t,e,s)=>{if("string"==typeof e&&!isNaN(Number(e))){const i=Number(e);return t.set(i,s),!0}return t[e]=s,!0}})}get length(){return 4*this.buffer.byteLength}get(t){if(t<0||t>=this.length)throw new RangeError(`Index ${t} is out of bounds`);return r.u.getHalfNibbleArrayIndex(this.data,0,t)}set(t,e){if(t<0||t>=this.length)throw new RangeError(`Index ${t} is out of bounds`);if(e<0||e>3)throw new RangeError(`Value ${e} is out of bounds for a half nibble`);r.u.setHalfNibbleArrayIndex(this.data,0,t,e)}[Symbol.iterator](){let t=0;return{next:()=>t<this.length?{value:this.get(t++),done:!1}:{value:void 0,done:!0}}}forEach(t){for(let e=0;e<this.length;e++)t(this.get(e),e,this)}}class n{buffer;data;constructor(t){return this.buffer=t,this.data=new DataView(ArrayBuffer.isView(t)?t.buffer:t),new Proxy(this,{get:(t,e)=>{if("string"==typeof e&&!isNaN(Number(e))){const s=Number(e);return t.get(s)}return t[e]},set:(t,e,s)=>{if("string"==typeof e&&!isNaN(Number(e))){const i=Number(e);return t.set(i,s),!0}return t[e]=s,!0}})}get length(){return 2*this.buffer.byteLength}get(t){if(t<0||t>=this.length)throw new RangeError(`Index ${t} is out of bounds`);return r.u.getNibbleArrayIndex(this.data,0,t)}set(t,e){if(t<0||t>=this.length)throw new RangeError(`Index ${t} is out of bounds`);if(e<0||e>15)throw new RangeError(`Value ${e} is out of bounds for a nibble`);r.u.setNibbleArrayIndex(this.data,0,t,e)}[Symbol.iterator](){let t=0;return{next:()=>t<this.length?{value:this.get(t++),done:!1}:{value:void 0,done:!0}}}forEach(t){for(let e=0;e<this.length;e++)t(this.get(e),e,this)}}const a=(t,e,s=!1)=>{let r=e;if(t>15&&t<=255)r=Uint8Array.from(e);else if(t>4&&t<=15){r=new Uint8Array(e.length/2);const t=new n(r);for(let s=0;s<e.length;s++)t[s]=e[s]}else if(t>2&&t<=4){r=new Uint8Array(e.length/4);const t=new o(r);for(let s=0;s<e.length;s++)t[s]=e[s]}else if(2==t){r=new Uint8Array(e.length/8);const t=new i.P(r);for(let s=0;s<e.length;s++)t[s]=e[s]}if(s&&!(r.buffer instanceof SharedArrayBuffer)){const t=new SharedArrayBuffer(r.byteLength),e=new Uint8Array(t);return e.set(r),e}return r},h=(t,e)=>2==t?new i.P(e):t>2&&t<=4?new o(e):t>4&&t<=15?new n(e):e},82931:(t,e,s)=>{"use strict";s.d(e,{V:()=>ws});var i=s(46498),r=s(98899),o=s(25701),n=s(22879),a=s(46300),h=s(99638);class l{static flatIndex=h.F$.GetXYZOrder();static getIndex(t,e,s){return this.flatIndex.getIndexXYZ(t+1,e+1,s+1)}}l.flatIndex.setBounds(3,3,3);const c=[];for(let t=0;t<l.flatIndex.size;t++)c[t]=l.flatIndex.getXYZ(t).map((t=>t-1));class d{data;view;constructor(t){this.data=t,this.view=new Uint16Array(t.buffer)}getByteIndex(t,e){return t*this.data.faceByteCount*l.flatIndex.size+e*this.data.faceByteCount}getValue(t,e,s){const i=this.view[this.getByteIndex(t,e)+s];return 65535==i?-1:i}setValue(t,e,s,i=-1){return this.view[this.getByteIndex(t,e)+s]=i}}var u,f=s(62307);class g{data;view;constructor(t){this.data=t,this.view=new DataView(t.buffer)}getByteIndex(t,e){return t*this.data.vertexByteCount*l.flatIndex.size+e*this.data.vertexByteCount}getValue(t,e,s){return f.u.getBitArrayIndex(this.view,this.getByteIndex(t,e),s)}setValue(t,e,s,i=1){f.u.setBitArrayIndex(this.view,this.getByteIndex(t,e),s,i)}}!function(t){t[t.Enabled=0]="Enabled",t[t.Fliped=1]="Fliped",t[t.Texture=2]="Texture",t[t.Rotation=3]="Rotation",t[t.Transparent=4]="Transparent",t[t.UVs=5]="UVs",t[t.Index=6]="Index"}(u||(u={}));const p=t=>{const e=[];return e[u.Enabled]=!0,e[u.Fliped]=!1,e[u.Texture]=0,e[u.Rotation]=0,e[u.Transparent]=!1,e[u.UVs]=[[1,1],[0,1],[0,0],[1,0]],e[u.Index]=t,e};class m{static ArgIndexes=u;static CreateArgs(){const t=[];for(let e=0;e<6;e++)t[e]=p(e);return t}}class v{geometryPaletteId;geomtry;data;transform;faceIndex=-1;vertexIndex=-1;faceCount=-1;vertexCount=-1;tool;origin;constructor(t,e,s,i){this.geometryPaletteId=t,this.geomtry=e,this.data=s,this.transform=i}}var y,x;(x=y||(y={}))[x.TopRight=0]="TopRight",x[x.TopLeft=1]="TopLeft",x[x.BottomLeft=2]="BottomLeft",x[x.BottomRight=3]="BottomRight";const A=[y.TopRight,y.TopLeft,y.BottomLeft,y.BottomRight];var b;!function(t){t[t.Up=0]="Up",t[t.Down=1]="Down",t[t.North=2]="North",t[t.South=3]="South",t[t.East=4]="East",t[t.West=5]="West"}(b||(b={}));const w=Object.freeze([b.Up,b.Down,b.North,b.South,b.East,b.West]),I=Object.freeze({[b.Up]:[0,1,0],[b.Down]:[0,-1,0],[b.North]:[0,0,1],[b.South]:[0,0,-1],[b.East]:[1,0,0],[b.West]:[-1,0,0]});b.Up,b.Down,b.Down,b.Up,b.North,b.South,b.South,b.North,b.East,b.West,b.West,b.East,b.Up,h.$f.North,b.Down,h.$f.South,b.North,h.$f.North,b.South,h.$f.South,b.East,h.$f.East,b.West,h.$f.West,h.$f.North,b.North,h.$f.South,b.South,h.$f.West,b.West,h.$f.East,b.East,h.$f.NorthEast,b.Up,h.$f.NorthWest,b.Up,h.$f.SouthEast,b.Up,h.$f.SouthWest,b.Up,b.Up,b.Down,b.North,b.South,b.East,b.West,b.Up,b.Down,b.North,b.South,b.East,b.West;var S=s(3338);const T=new S.$,_=[];_[b.Up]=[],_[b.Up][y.TopRight]=[1,1,0,0,1,1,1,1,1],_[b.Up][y.TopLeft]=[-1,1,0,0,1,1,-1,1,1],_[b.Up][y.BottomLeft]=[-1,1,0,0,1,-1,-1,1,-1],_[b.Up][y.BottomRight]=[1,1,0,0,1,-1,1,1,-1],_[b.Down]=[],_[b.Down][y.TopRight]=[-1,-1,0,0,-1,1,-1,-1,1],_[b.Down][y.TopLeft]=[1,-1,0,0,-1,1,1,-1,1],_[b.Down][y.BottomLeft]=[1,-1,0,0,-1,-1,1,-1,-1],_[b.Down][y.BottomRight]=[-1,-1,0,0,-1,-1,-1,-1,-1],_[b.East]=[],_[b.East][y.TopRight]=[1,0,1,1,1,0,1,1,1],_[b.East][y.TopLeft]=[1,0,-1,1,1,0,1,1,-1],_[b.East][y.BottomLeft]=[1,0,-1,1,-1,0,1,-1,-1],_[b.East][y.BottomRight]=[1,0,1,1,-1,0,1,-1,1],_[b.West]=[],_[b.West][y.TopRight]=[-1,0,-1,-1,1,0,-1,1,-1],_[b.West][y.TopLeft]=[-1,0,1,-1,1,0,-1,1,1],_[b.West][y.BottomLeft]=[-1,0,1,-1,-1,0,-1,-1,1],_[b.West][y.BottomRight]=[-1,0,-1,-1,-1,0,-1,-1,-1],_[b.South]=[],_[b.South][y.TopRight]=[1,0,-1,0,1,-1,1,1,-1],_[b.South][y.TopLeft]=[-1,0,-1,0,1,-1,-1,1,-1],_[b.South][y.BottomLeft]=[-1,0,-1,0,-1,-1,-1,-1,-1],_[b.South][y.BottomRight]=[1,0,-1,0,-1,-1,1,-1,-1],_[b.North]=[],_[b.North][y.TopRight]=[-1,0,1,0,1,1,-1,1,1],_[b.North][y.TopLeft]=[1,0,1,0,1,1,1,1,1],_[b.North][y.BottomLeft]=[1,0,1,0,-1,1,1,-1,1],_[b.North][y.BottomRight]=[-1,0,1,0,-1,1,-1,-1,1];const z=new Int8Array(216),L=[y.TopRight,y.TopLeft,y.BottomLeft,y.BottomRight];for(const t of w)for(let e=0;e<L.length;e++)for(let s=0;s<9;s++)z[36*t+9*L[e]+s]=_[t][L[e]][s];const B=[];for(const t of w){B[t]??=[];for(let e=0;e<L.length;e++){B[t][L[e]]??=[];let s=0;for(let i=0;i<9;i+=3){const r=_[t][L[e]][i],o=_[t][L[e]][i+1],n=_[t][L[e]][i+2];B[t][L[e]][s]=l.getIndex(r,o,n),s++}}}l.getIndex(0,0,0);const C=[];function R(t,e,s,i){return t>e&&t>s&&t>i}function U(t,e,s,i){return o=i,!(t==(r=e)&&r==o&&o==s||R(i,e,s,t)||R(e,s,i,t)||!R(t,e,s,i)&&!R(s,e,i,t)&&!((t+s)/2>(e+i)/2));var r,o}function V(t,e,s,i){let r,o,n=!1;switch(t){case b.Up:r=e,o=i;break;case b.Down:r=e,o=i,n=!0;break;case b.North:r=e,o=s,n=!0;break;case b.South:r=e,o=s;break;case b.East:r=i,o=s;break;case b.West:r=i,o=s,n=!0}return function(t,e,s=!1){let i=(1-(t=Math.max(0,Math.min(1,t))))*(1-(e=Math.max(0,Math.min(1,e)))),r=t*(1-e),o=t*e,n=(1-t)*e;return s?[n,o,r,i]:[o,n,i,r]}(r,o,n)}C[b.Up]=l.getIndex(0,1,0),C[b.Down]=l.getIndex(0,-1,0),C[b.North]=l.getIndex(0,0,1),C[b.South]=l.getIndex(0,0,-1),C[b.East]=l.getIndex(1,0,0),C[b.West]=l.getIndex(-1,0,0);const M=[0,0,0,0],D=[0,0,0,0],k=[0,0,0,0],P=[0,0,0,0],E=[0,0,0,0];function N(t,e){return T.getLightValuesToRef(t[0],M),T.getLightValuesToRef(t[1],D),T.getLightValuesToRef(t[2],k),T.getLightValuesToRef(t[3],P),E[0]=M[0]*e[0]+D[0]*e[1]+k[0]*e[2]+P[0]*e[3],E[1]=M[1]*e[0]+D[1]*e[1]+k[1]*e[2]+P[1]*e[3],E[2]=M[2]*e[0]+D[2]*e[1]+k[2]*e[2]+P[2]*e[3],E[3]=M[3]*e[0]+D[3]*e[1]+k[3]*e[2]+P[3]*e[3],T.setLightValues(E)}const F=(t,e)=>{const s=[];for(const i of A){const{x:r,y:o,z:n}=t.positions.vertices[i];s[i]=V(e,r,o,n)}return s};class O{vertices;constructor(t){this.vertices=t}getAsArray(){return[this.vertices[y.TopRight],this.vertices[y.TopLeft],this.vertices[y.BottomLeft],this.vertices[y.BottomRight]]}setVertex(t,e){this.vertices[t]=e}getVertex(t){return this.vertices[t]}setAll(t){this.vertices[y.TopRight]=t,this.vertices[y.TopLeft]=t,this.vertices[y.BottomLeft]=t,this.vertices[y.BottomRight]=t}set(t,e,s,i){this.vertices[y.TopRight]=t,this.vertices[y.TopLeft]=e,this.vertices[y.BottomLeft]=s,this.vertices[y.BottomRight]=i}isEqualTo(t,e,s,i){return this.vertices[y.TopRight]==t&&this.vertices[y.TopLeft]==e&&this.vertices[y.BottomLeft]==s&&this.vertices[y.BottomRight]==i}isAllEqualTo(t){return this.vertices[y.TopRight]==t&&this.vertices[y.TopLeft]==t&&this.vertices[y.BottomLeft]==t&&this.vertices[y.BottomRight]==t}[Symbol.iterator](){let t=y.TopRight;const e=this.vertices;return{next:()=>t<y.BottomRight?{value:e[t++],done:!1}:{value:void 0,done:!0}}}clone(){return new O({[y.TopRight]:structuredClone(this.vertices[y.TopRight]),[y.TopLeft]:structuredClone(this.vertices[y.TopLeft]),[y.BottomLeft]:structuredClone(this.vertices[y.BottomLeft]),[y.BottomRight]:structuredClone(this.vertices[y.BottomRight])})}}class Q extends O{vertices;constructor(t={[y.TopRight]:h.Az.Create(),[y.TopLeft]:h.Az.Create(),[y.BottomLeft]:h.Az.Create(),[y.BottomRight]:h.Az.Create()}){super(t),this.vertices=t}setFromQuadData(t){h.Az.Copy(this.vertices[y.TopRight],t.vertices[y.TopRight]),h.Az.Copy(this.vertices[y.TopLeft],t.vertices[y.TopLeft]),h.Az.Copy(this.vertices[y.BottomLeft],t.vertices[y.BottomLeft]),h.Az.Copy(this.vertices[y.BottomRight],t.vertices[y.BottomRight])}addToVertex(t,e){h.Az.AddInPlace(this.vertices[t],e)}subtractFromVertex(t,e){h.Az.SubtractInPlace(this.vertices[t],e)}addAll(t){this.addToVertex(y.TopRight,t),this.addToVertex(y.TopLeft,t),this.addToVertex(y.BottomLeft,t),this.addToVertex(y.BottomRight,t)}subtractAll(t){this.subtractFromVertex(y.TopRight,t),this.subtractFromVertex(y.TopLeft,t),this.subtractFromVertex(y.BottomLeft,t),this.subtractFromVertex(y.BottomRight,t)}isEqualTo(t,e,s,i){return h.Az.Equals(this.vertices[y.TopRight],t)&&h.Az.Equals(this.vertices[y.TopLeft],e)&&h.Az.Equals(this.vertices[y.BottomLeft],s)&&h.Az.Equals(this.vertices[y.BottomRight],i)}isAllEqualTo(t){return h.Az.Equals(this.vertices[y.TopRight],t)&&h.Az.Equals(this.vertices[y.TopLeft],t)&&h.Az.Equals(this.vertices[y.BottomLeft],t)&&h.Az.Equals(this.vertices[y.BottomRight],t)}clone(){return new Q({[y.TopRight]:h.Az.Clone(this.vertices[y.TopRight]),[y.TopLeft]:h.Az.Clone(this.vertices[y.TopLeft]),[y.BottomLeft]:h.Az.Clone(this.vertices[y.BottomLeft]),[y.BottomRight]:h.Az.Clone(this.vertices[y.BottomRight])})}}class q extends O{vertices;constructor(t={[y.TopRight]:h.xt.Create(),[y.TopLeft]:h.xt.Create(),[y.BottomLeft]:h.xt.Create(),[y.BottomRight]:h.xt.Create()}){super(t),this.vertices=t}setFromQuadData(t){h.xt.Copy(this.vertices[y.TopRight],t.vertices[y.TopRight]),h.xt.Copy(this.vertices[y.TopLeft],t.vertices[y.TopLeft]),h.xt.Copy(this.vertices[y.BottomLeft],t.vertices[y.BottomLeft]),h.xt.Copy(this.vertices[y.BottomRight],t.vertices[y.BottomRight])}addToVertex(t,e){h.xt.AddInPlace(this.vertices[t],e)}subtractFromVertex(t,e){h.xt.SubtractInPlace(this.vertices[t],e)}addAll(t){this.addToVertex(y.TopRight,t),this.addToVertex(y.TopLeft,t),this.addToVertex(y.BottomLeft,t),this.addToVertex(y.BottomRight,t)}subtractAll(t){this.subtractFromVertex(y.TopRight,t),this.subtractFromVertex(y.TopLeft,t),this.subtractFromVertex(y.BottomLeft,t),this.subtractFromVertex(y.BottomRight,t)}isEqualTo(t,e,s,i){return h.xt.Equals(this.vertices[y.TopRight],t)&&h.xt.Equals(this.vertices[y.TopLeft],e)&&h.xt.Equals(this.vertices[y.BottomLeft],s)&&h.xt.Equals(this.vertices[y.BottomRight],i)}isAllEqualTo(t){return h.xt.Equals(this.vertices[y.TopRight],t)&&h.xt.Equals(this.vertices[y.TopLeft],t)&&h.xt.Equals(this.vertices[y.BottomLeft],t)&&h.xt.Equals(this.vertices[y.BottomRight],t)}clone(){return new q({[y.TopRight]:h.xt.Clone(this.vertices[y.TopRight]),[y.TopLeft]:h.xt.Clone(this.vertices[y.TopLeft]),[y.BottomLeft]:h.xt.Clone(this.vertices[y.BottomLeft]),[y.BottomRight]:h.xt.Clone(this.vertices[y.BottomRight])})}}class W extends O{vertices;constructor(t={[y.TopRight]:0,[y.TopLeft]:0,[y.BottomLeft]:0,[y.BottomRight]:0}){super(t),this.vertices=t}setFromQuadData(t){this.vertices[y.TopRight]=t.vertices[y.TopRight],this.vertices[y.TopLeft]=t.vertices[y.TopLeft],this.vertices[y.BottomLeft]=t.vertices[y.BottomLeft],this.vertices[y.BottomRight]=t.vertices[y.BottomRight]}subtractFromVertex(t,e){this.vertices[t]-=e}addAll(t){this.vertices[y.TopRight]+=t,this.vertices[y.TopLeft]+=t,this.vertices[y.BottomLeft]+=t,this.vertices[y.BottomRight]+=t}add(t,e,s,i){this.vertices[y.TopRight]+=t,this.vertices[y.TopLeft]+=e,this.vertices[y.BottomLeft]+=s,this.vertices[y.BottomRight]+=i}subtractAll(t){this.vertices[y.TopRight]-=t,this.vertices[y.TopLeft]-=t,this.vertices[y.BottomLeft]-=t,this.vertices[y.BottomRight]-=t}subtract(t,e,s,i){this.vertices[y.TopRight]+=t,this.vertices[y.TopLeft]+=e,this.vertices[y.BottomLeft]+=s,this.vertices[y.BottomRight]+=i}isGreaterThan(t,e,s,i){return!(this.vertices[y.TopRight]<t||this.vertices[y.TopLeft]<e||this.vertices[y.BottomLeft]<s||this.vertices[y.BottomRight]<i)}isAllGreaterThan(t){return!(this.vertices[y.TopRight]<t||this.vertices[y.TopLeft]<t||this.vertices[y.BottomLeft]<t||this.vertices[y.BottomRight]<t)}isLessThan(t,e,s,i){return!(this.vertices[y.TopRight]>t||this.vertices[y.TopLeft]>e||this.vertices[y.BottomLeft]>s||this.vertices[y.BottomRight]>i)}isAllLessThan(t){return!(this.vertices[y.TopRight]>t||this.vertices[y.TopLeft]>t||this.vertices[y.BottomLeft]>t||this.vertices[y.BottomRight]>t)}clone(){return new W({[y.TopRight]:this.vertices[y.TopRight],[y.TopLeft]:this.vertices[y.TopLeft],[y.BottomLeft]:this.vertices[y.BottomLeft],[y.BottomRight]:this.vertices[y.BottomRight]})}}class j{static FullUVs=Object.freeze([[1,1],[0,1],[0,0],[1,0]]);static RotateUvs(t,e){const s=h.Jd.RotationZ(e),i=[.5,.5];return[h.xt.RotateAroundPivotArray(s,t[0],i),h.xt.RotateAroundPivotArray(s,t[1],i),h.xt.RotateAroundPivotArray(s,t[2],i),h.xt.RotateAroundPivotArray(s,t[3],i)]}static Create(t,e,s,i){return new j({positions:t,uvs:e,doubleSided:s,orientation:i})}static RotateVertices90Degrees(t,e=1){for(;e--;)t=[t[1],t[2],t[3],t[0]];return t}static GetQuadNormalRightHanded(t,e,s,i){const r=[e[0]-t[0],e[1]-t[1],e[2]-t[2]],o=[s[0]-t[0],s[1]-t[1],s[2]-t[2]],n=h.Az.NormalizeArray(h.Az.CrossArray(r,o)),a=[s[0]-t[0],s[1]-t[1],s[2]-t[2]],l=[i[0]-t[0],i[1]-t[1],i[2]-t[2]],c=h.Az.NormalizeArray(h.Az.CrossArray(a,l)),d=[h.Az.NormalizeArray([(n[0]+c[0])/2,(n[1]+c[1])/2,(n[2]+c[2])/2]),n,h.Az.NormalizeArray([(n[0]+c[0])/2,(n[1]+c[1])/2,(n[2]+c[2])/2]),c];for(let t=0;t<d.length;t++){const e=d[t];for(let t=0;t<3;t++)0===Math.abs(e[t])&&(e[t]=0)}return d}static GetQuadNormalLeftHanded(t,e,s,i){const r=[e[0]-t[0],e[1]-t[1],e[2]-t[2]],o=[s[0]-t[0],s[1]-t[1],s[2]-t[2]],n=h.Az.MultiplyScalarArray(h.Az.NormalizeArray(h.Az.CrossArray(r,o)),-1),a=[s[0]-t[0],s[1]-t[1],s[2]-t[2]],l=[i[0]-t[0],i[1]-t[1],i[2]-t[2]],c=h.Az.MultiplyScalarArray(h.Az.NormalizeArray(h.Az.CrossArray(a,l)),-1),d=[h.Az.NormalizeArray([(n[0]+c[0])/2,(n[1]+c[1])/2,(n[2]+c[2])/2]),n,h.Az.NormalizeArray([(n[0]+c[0])/2,(n[1]+c[1])/2,(n[2]+c[2])/2]),c];for(let t=0;t<d.length;t++){const e=d[t];for(let t=0;t<3;t++)0===Math.abs(e[t])&&(e[t]=0)}return d}static CalculateQuadPoints(t,e){const s=t.map(((t,s)=>e[s]!==t?s:-1)).filter((t=>-1!==t));let i,r;const o=e,n=t;s.includes(0)&&s.includes(2)?(i=[t[0],t[1],e[2]],r=[e[0],t[1],t[2]]):s.includes(0)&&s.includes(1)?(i=[t[0],e[1],t[2]],r=[e[0],t[1],t[2]]):s.includes(1)&&s.includes(2)&&(i=[t[0],e[1],t[2]],r=[t[0],t[1],e[2]]);const a=[e[0]-t[0],e[1]-t[1],e[2]-t[2]];let h=[0,0,0];return 0===a[0]?h[0]=1:0===a[1]?h[1]=1:0===a[2]&&(h[2]=1),{points:[o,i,n,r],normal:h}}static OrderQuadVertices(t,e){const s={north:t=>[t[0],t[1]],south:t=>[t[0],t[1]],east:t=>[t[2],t[1]],west:t=>[t[2],t[1]],up:t=>[t[0],t[2]],down:t=>[t[0],t[2]]},i=t.map((t=>s[e](t))),r=[(i[0][0]+i[1][0]+i[2][0]+i[3][0])/4,(i[0][1]+i[1][1]+i[2][1]+i[3][1])/4],o=t=>Math.atan2(t[1]-r[1],t[0]-r[0]),n=t.map(((t,e)=>({vertex:t,angle:o(i[e])})));return n.sort(((t,e)=>t.angle-e.angle)),[n[2].vertex,n[3].vertex,n[0].vertex,n[1].vertex]}positions=new Q;normals=new Q;uvs=new q;flip=!1;doubleSided=!1;orientation=0;constructor(t){t.positions&&this.setPositions(t.positions),t.uvs&&this.setUVs(t.uvs),t.doubleSided&&(this.doubleSided=t.doubleSided),void 0!==t.orientation&&(this.orientation=t.orientation)}setUVs([t,e,s,i]){return this.uvs.set(h.xt.FromArray(t),h.xt.FromArray(e),h.xt.FromArray(s),h.xt.FromArray(i)),this}scale(t,e,s){const i=h.Az.Create(t,e,s);for(const t of this.positions)h.Az.MultiplyInPlace(t,i);return this}transform(t,e,s){const i=h.Az.Create(t,e,s);for(const t of this.positions)h.Az.AddInPlace(t,i);return this}setPositions(t){if(2==t.length){const{points:e,normal:s}=j.CalculateQuadPoints(t[0],t[1]);this.positions.set(h.Az.FromArray(e[0]),h.Az.FromArray(e[1]),h.Az.FromArray(e[2]),h.Az.FromArray(e[3])),this.normals.set(h.Az.FromArray(s),h.Az.FromArray(s),h.Az.FromArray(s),h.Az.FromArray(s))}if(4==t.length){const[e,s,i,r]=j.GetQuadNormalLeftHanded(...t);this.positions.set(h.Az.FromArray(t[0]),h.Az.FromArray(t[1]),h.Az.FromArray(t[2]),h.Az.FromArray(t[3])),this.normals.set(h.Az.FromArray(e),h.Az.FromArray(s),h.Az.FromArray(i),h.Az.FromArray(r))}return this}clone(){return j.Create(this.positions.getAsArray().map((t=>h.Az.ToArray(t))),this.uvs.getAsArray().map((t=>h.xt.ToArray(t))))}}function G(t,e,s){e.x+s[0][0]<t.bounds.min[0]&&(t.bounds.min[0]=e.x+s[0][0]),e.y+s[0][1]<t.bounds.min[1]&&(t.bounds.min[1]=e.y+s[0][1]),e.z+s[0][2]<t.bounds.min[2]&&(t.bounds.min[2]=e.z+s[0][2]),e.x+s[1][0]>t.bounds.max[0]&&(t.bounds.max[0]=e.x+s[1][0]),e.y+s[1][1]>t.bounds.max[1]&&(t.bounds.max[1]=e.y+s[1][1]),e.z+s[1][2]>t.bounds.max[2]&&(t.bounds.max[2]=e.z+s[1][2])}function H(t){let e=1/0,s=1/0,i=1/0,r=-1/0,o=-1/0,n=-1/0;for(let a=0;a<t.length;a++){const[h,l,c]=t[a];h<e&&(e=h),l<s&&(s=l),c<i&&(i=c),h>r&&(r=h),l>o&&(o=l),c>n&&(n=c)}return[[e,s,i],[r,o,n]]}function Y(t,e){const s=[],i=h.Az.Create(...t[0]),r=h.Az.Create(...t[1]),o=[];o[b.Up]=j.Create([[r.x,r.y,r.z],[i.x,r.y,r.z],[i.x,r.y,i.z],[r.x,r.y,i.z]]),o[b.Down]=j.Create([[i.x,i.y,r.z],[r.x,i.y,r.z],[r.x,i.y,i.z],[i.x,i.y,i.z]]),o[b.North]=j.Create([[i.x,r.y,r.z],[r.x,r.y,r.z],[r.x,i.y,r.z],[i.x,i.y,r.z]]),o[b.South]=j.Create([[r.x,r.y,i.z],[i.x,r.y,i.z],[i.x,i.y,i.z],[r.x,i.y,i.z]]),o[b.East]=j.Create([[r.x,r.y,r.z],[r.x,r.y,i.z],[r.x,i.y,i.z],[r.x,i.y,r.z]]),o[b.West]=j.Create([[i.x,r.y,i.z],[i.x,r.y,r.z],[i.x,i.y,r.z],[i.x,i.y,i.z]]);const n=new Array(o.length);for(let t=0;t<o.length;t++){const e=[],s=o[t].positions.getAsArray();for(let t=0;t<4;t++)e.push([s[t].x,s[t].y,s[t].z]);n[t]=H(e)}return s[b.Up]=F(o[b.Up],b.Up),s[b.Down]=F(o[b.Down],b.Down),s[b.North]=F(o[b.North],b.North),s[b.South]=F(o[b.South],b.South),s[b.East]=F(o[b.East],b.East),s[b.West]=F(o[b.West],b.West),{quads:o,vertexWeights:s,quadBounds:n}}var X;!function(t){t[t.Panel=1]="Panel",t[t.CrossPanel=2]="CrossPanel",t[t.Box=3]="Box"}(X||(X={}));class ${static AnimationStates={WindAffected:X};static LightMask=65535;static AOMask=15;static AnimationMask=4095;static TextureIndexMax=65535;static createTextureIndex(t,e){let s=0;return s=s&~this.TextureIndexMax|t&this.TextureIndexMax,s=s&~(this.TextureIndexMax<<16)|(e&this.TextureIndexMax)<<16,s}static createAttribute(t,e,s){let i=0;return i=i&~this.LightMask|t&this.LightMask,i=i&~(this.AOMask<<16)|(e&this.AOMask)<<16,i=i&~(this.AnimationMask<<20)|(s&this.AnimationMask)<<20,i}}class Z{static VertexFloatSize=24;static VertexByteSize=4*this.VertexFloatSize;static PositionOffset=0;static NormalOffset=4;static TextureIndexOffset=8;static UVOffset=12;static ColorOffset=14;static VoxelDataOFfset=18;get positionX(){return this.data[this.trueIndex+Z.PositionOffset]}set positionX(t){this.data[this.trueIndex+Z.PositionOffset]=t}get positionY(){return this.data[this.trueIndex+Z.PositionOffset+1]}set positionY(t){this.data[this.trueIndex+Z.PositionOffset+1]=t}get positionZ(){return this.data[this.trueIndex+Z.PositionOffset+2]}set positionZ(t){this.data[this.trueIndex+Z.PositionOffset+2]=t}get normalX(){return this.data[this.trueIndex+Z.NormalOffset]}set normalX(t){this.data[this.trueIndex+Z.NormalOffset]=t}get normalY(){return this.data[this.trueIndex+Z.NormalOffset+1]}set normalY(t){this.data[this.trueIndex+Z.NormalOffset+1]=t}get normalZ(){return this.data[this.trueIndex+Z.NormalOffset+2]}set normalZ(t){this.data[this.trueIndex+Z.NormalOffset+2]=t}get voxelData(){return this.data[this.trueIndex+Z.VoxelDataOFfset]}set voxelData(t){this.data[this.trueIndex+Z.VoxelDataOFfset]=t}get textureIndexX(){return this.data[this.trueIndex+Z.TextureIndexOffset]}set textureIndexX(t){this.data[this.trueIndex+Z.TextureIndexOffset]=t}get textureIndexY(){return this.data[this.trueIndex+Z.TextureIndexOffset+1]}set textureIndexY(t){this.data[this.trueIndex+Z.TextureIndexOffset+1]=t}get textureIndexZ(){return this.data[this.trueIndex+Z.TextureIndexOffset+2]}set textureIndexZ(t){this.data[this.trueIndex+Z.TextureIndexOffset+2]=t}get uvX(){return this.data[this.trueIndex+Z.UVOffset]}set uvX(t){this.data[this.trueIndex+Z.UVOffset]=t}get uvY(){return this.data[this.trueIndex+Z.UVOffset+1]}set uvY(t){this.data[this.trueIndex+Z.UVOffset+1]=t}get colorR(){return this.data[this.trueIndex+Z.ColorOffset]}set colorR(t){this.data[this.trueIndex+Z.ColorOffset]=t}get colorG(){return this.data[this.trueIndex+Z.ColorOffset+1]}set colorG(t){this.data[this.trueIndex+Z.ColorOffset+1]=t}get colorB(){return this.data[this.trueIndex+Z.ColorOffset+2]}set colorB(t){this.data[this.trueIndex+Z.ColorOffset+2]=t}trueIndex=0;_index=0;data;get index(){return this._index}set index(t){this._index=t,this.trueIndex=t*Z.VertexFloatSize}constructor(t){t&&(this.data=t)}toJSON(){return{position:[this.positionX,this.positionY,this.positionZ],normal:[this.normalX,this.normalY,this.normalZ],voxelData:this.voxelData,textureIndex:[this.textureIndexX,this.textureIndexY,this.textureIndexZ],uv:[this.uvX,this.uvY],color:[this.colorR,this.colorG,this.colorB]}}}const K=[],J=new Z;class tt{static addQuad(t,e,s){if(!t.mesh)return;J.data=t.mesh.buffer;const i=t.vars.light,r=t.vars.ao,o=t.vars.animation,n=t.vars.textureIndex,a=t.vars.overlayTextures,h=s.positions.vertices[0],l=s.positions.vertices[1],c=s.positions.vertices[2],d=s.positions.vertices[3],u=s.normals.vertices[0],f=s.normals.vertices[1],g=s.normals.vertices[2],p=s.normals.vertices[3],m=t.mesh.indices;let v=t.mesh.indicieCount,x=s.doubleSided?2:1;const A=s.flip;let b=s.orientation;for(;x--;){const x=t.mesh.vertexCount;A?(J.index=x,J.positionX=l.x+e.x,J.positionY=l.y+e.y,J.positionZ=l.z+e.z,J.voxelData=$.createAttribute(i.vertices[y.TopLeft],r.vertices[y.TopLeft],o.vertices[y.TopLeft]),J.uvX=s.uvs.vertices[y.TopLeft].x,J.uvY=s.uvs.vertices[y.TopLeft].y,J.index=x+1,J.positionX=h.x+e.x,J.positionY=h.y+e.y,J.positionZ=h.z+e.z,J.voxelData=$.createAttribute(i.vertices[y.TopRight],r.vertices[y.TopRight],o.vertices[y.TopRight]),J.uvX=s.uvs.vertices[y.TopRight].x,J.uvY=s.uvs.vertices[y.TopRight].y,J.index=x+2,J.positionX=d.x+e.x,J.positionY=d.y+e.y,J.positionZ=d.z+e.z,J.voxelData=$.createAttribute(i.vertices[y.BottomRight],r.vertices[y.BottomRight],o.vertices[y.BottomRight]),J.uvX=s.uvs.vertices[y.BottomRight].x,J.uvY=s.uvs.vertices[y.BottomRight].y,J.index=x+3,J.positionX=c.x+e.x,J.positionY=c.y+e.y,J.positionZ=c.z+e.z,J.voxelData=$.createAttribute(i.vertices[y.BottomLeft],r.vertices[y.BottomLeft],o.vertices[y.BottomLeft]),J.uvX=s.uvs.vertices[y.BottomLeft].x,J.uvY=s.uvs.vertices[y.BottomLeft].y):(J.index=x,J.positionX=h.x+e.x,J.positionY=h.y+e.y,J.positionZ=h.z+e.z,J.voxelData=$.createAttribute(i.vertices[y.TopRight],r.vertices[y.TopRight],o.vertices[y.TopRight]),J.uvX=s.uvs.vertices[y.TopRight].x,J.uvY=s.uvs.vertices[y.TopRight].y,J.index=x+1,J.positionX=l.x+e.x,J.positionY=l.y+e.y,J.positionZ=l.z+e.z,J.voxelData=$.createAttribute(i.vertices[y.TopLeft],r.vertices[y.TopLeft],o.vertices[y.TopLeft]),J.uvX=s.uvs.vertices[y.TopLeft].x,J.uvY=s.uvs.vertices[y.TopLeft].y,J.index=x+2,J.positionX=c.x+e.x,J.positionY=c.y+e.y,J.positionZ=c.z+e.z,J.voxelData=$.createAttribute(i.vertices[y.BottomLeft],r.vertices[y.BottomLeft],o.vertices[y.BottomLeft]),J.uvX=s.uvs.vertices[y.BottomLeft].x,J.uvY=s.uvs.vertices[y.BottomLeft].y,J.index=x+3,J.positionX=d.x+e.x,J.positionY=d.y+e.y,J.positionZ=d.z+e.z,J.voxelData=$.createAttribute(i.vertices[y.BottomRight],r.vertices[y.BottomRight],o.vertices[y.BottomRight]),J.uvX=s.uvs.vertices[y.BottomRight].x,J.uvY=s.uvs.vertices[y.BottomRight].y),J.index=x,J.textureIndexX=$.createTextureIndex(n,a.vertices[y.TopRight]),J.textureIndexY=$.createTextureIndex(a.vertices[y.TopLeft],a.vertices[y.BottomLeft]),J.textureIndexZ=$.createTextureIndex(a.vertices[y.BottomRight],0),J.normalX=u.x,J.normalY=u.y,J.normalZ=u.z,J.index=x+1,J.textureIndexX=$.createTextureIndex(n,a.vertices[y.TopRight]),J.textureIndexY=$.createTextureIndex(a.vertices[y.TopLeft],a.vertices[y.BottomLeft]),J.textureIndexZ=$.createTextureIndex(a.vertices[y.BottomRight],0),J.normalX=f.x,J.normalY=f.y,J.normalZ=f.z,J.index=x+2,J.textureIndexX=$.createTextureIndex(n,a.vertices[y.TopRight]),J.textureIndexY=$.createTextureIndex(a.vertices[y.TopLeft],a.vertices[y.BottomLeft]),J.textureIndexZ=$.createTextureIndex(a.vertices[y.BottomRight],0),J.normalX=g.x,J.normalY=g.y,J.normalZ=g.z,J.index=x+3,J.textureIndexX=$.createTextureIndex(n,a.vertices[y.TopRight]),J.textureIndexY=$.createTextureIndex(a.vertices[y.TopLeft],a.vertices[y.BottomLeft]),J.textureIndexZ=$.createTextureIndex(a.vertices[y.BottomRight],0),J.normalX=p.x,J.normalY=p.y,J.normalZ=p.z,b||A?!b&&A&&(m[v++]=x,m[v++]=x+3,m[v++]=x+2,m[v++]=x+2,m[v++]=x+1,m[v++]=x):(m[v++]=x,m[v++]=x+1,m[v++]=x+2,m[v++]=x+2,m[v++]=x+3,m[v++]=x),b&&!A?(m[v++]=x,m[v++]=x+3,m[v++]=x+2,m[v++]=x+2,m[v++]=x+1,m[v++]=x):b&&A&&(m[v++]=x,m[v++]=x+1,m[v++]=x+2,m[v++]=x+2,m[v++]=x+3,m[v++]=x),t.mesh.addVerticies(4,6)}J.data=K}}const et=m.ArgIndexes;class st extends v{quads;quadBounds=[];vertexWeights;worldLight;worldAO;lightData=new S.$;init(){this.faceCount=6,this.vertexCount=4*this.faceCount;const{quads:t,vertexWeights:e,quadBounds:s}=Y(this.data.points,this.transform);this.quads=t,this.vertexWeights=e,this.quadBounds=s}isExposed(t){const e=t+this.faceIndex,s=this.geomtry.faceCullMap[e];if(!s)return!0;const i=this.tool;for(let t=0;t<s.length;t++){const r=s[t],o=c[r],n=yt.getHash(i.nVoxel,i.position.x+o[0],i.position.y+o[1],i.position.z+o[2]),a=yt.space.getGeomtry(n),h=yt.space.getConditionalGeomtry(n);if(a)for(let t=0;t<a.length;t++){const s=a[t];if(yt.isRulesless(s))continue;const i=this.geomtry.cullIndex.getValue(s,r,e);if(i>-1&&!yt.space.getConstructor(n)?.isShapeStateFaceTransparent(yt.space.modCache[n],yt.space.stateCache[n],s,i))return!1}if(h)for(let t=0;t<h.length;t++){const s=h[t];for(let t=0;t<s.length;t++){const i=s[t];if(yt.isRulesless(i))continue;const o=this.geomtry.cullIndex.getValue(i,r,e);if(o>-1&&!yt.space.getConstructor(n)?.isCondtionalStateFaceTransparent(yt.space.modCache[n],yt.space.stateCache[n],i,o))return!1}}}return!0}determineShading(t){const e=this.tool,s=e.lightData[t],i=this.tool.voxel.isLightSource()||this.tool.voxel.noAO(),r=this.worldLight,o=this.worldAO;for(let n=0;n<4;n++){if(o.vertices[n]=0,r.vertices[n]=N(s,this.vertexWeights[t][n]),i)continue;const a=this.vertexIndex+4*t+n,h=this.geomtry.vertexHitMap[a];if(h)for(let t=0;t<h.length;t++){const s=h[t],i=c[s],r=yt.getHash(e.nVoxel,e.position.x+i[0],e.position.y+i[1],e.position.z+i[2]);if(1===yt.space.noCastAO[r])continue;const l=yt.space.getGeomtry(r),d=yt.space.getConditionalGeomtry(r);if(!l&&!d)continue;let u=0,f=!1;if(l){u=l.length;for(let t=0;t<u;t++)if(this.geomtry.aoIndex.getValue(l[t],s,a)){o.vertices[n]=1,f=!0;break}}if(d){u=d.length;for(let t=0;t<u;t++){const e=d[t].length;for(let i=0;i<e;i++)if(this.geomtry.aoIndex.getValue(d[t][i],s,a)){o.vertices[n]=1;break}}}}}}shouldFlip(){return!!U(this.worldAO.vertices[0],this.worldAO.vertices[1],this.worldAO.vertices[2],this.worldAO.vertices[3])||U(this.lightData.getS(this.worldLight.vertices[0]),this.lightData.getS(this.worldLight.vertices[1]),this.lightData.getS(this.worldLight.vertices[2]),this.lightData.getS(this.worldLight.vertices[3]))||U(this.lightData.sumRGB(this.worldLight.vertices[0]),this.lightData.sumRGB(this.worldLight.vertices[1]),this.lightData.sumRGB(this.worldLight.vertices[2]),this.lightData.sumRGB(this.worldLight.vertices[3]))}add(t,e,s,i){this.tool=t,this.origin=t.position,this.worldAO=t.vars.ao,this.worldLight=t.vars.light;for(let e=0;e<6;e++)if(i[e][et.Enabled]&&this.isExposed(e)){t.calculateFaceData(e),this.determineShading(e);const r=i[e],o=this.quads[e];o.flip=this.shouldFlip()||r[et.Fliped],t.vars.textureIndex=r[et.Texture];const n=r[et.UVs];o.uvs.vertices[0].x=n[0][0],o.uvs.vertices[0].y=n[0][1],o.uvs.vertices[1].x=n[1][0],o.uvs.vertices[1].y=n[1][1],o.uvs.vertices[2].x=n[2][0],o.uvs.vertices[2].y=n[2][1],o.uvs.vertices[3].x=n[3][0],o.uvs.vertices[3].y=n[3][1],tt.addQuad(t,s,o),G(t,s,this.quadBounds[e])}this.worldLight.setAll(0),this.worldAO.setAll(0)}}var it;!function(t){t[t.Enabled=0]="Enabled",t[t.Fliped=1]="Fliped",t[t.Texture=2]="Texture",t[t.Rotation=3]="Rotation",t[t.Transparent=4]="Transparent",t[t.DoubleSided=5]="DoubleSided",t[t.UVs=6]="UVs"}(it||(it={}));class rt{static ArgIndexes=it;static CreateArgs(){const t=[];return t[it.Enabled]=!0,t[it.Fliped]=!1,t[it.Texture]=0,t[it.Rotation]=0,t[it.Transparent]=!1,t[it.DoubleSided]=!1,t[it.UVs]=[[1,1],[0,1],[0,0],[1,0]],t}}function ot(t){return t*Math.PI/180}function nt(t,e){const s=function(t,e){const s={...t.positions.vertices[y.TopRight]},i={...t.positions.vertices[y.TopLeft]},r={...t.positions.vertices[y.BottomLeft]},o={...t.positions.vertices[y.BottomRight]},n=[s,i,r,o],a={x:(s.x+i.x+r.x+o.x)/4,y:(s.y+i.y+r.y+o.y)/4,z:(s.z+i.z+r.z+o.z)/4};let l=1,c=1,d=1;if(e.scale){const[t,s,i]=e.scale;l=t,c=s,d=i}if(e.flip){const[t,s,i]=e.flip;t&&(l*=-1),s&&(c*=-1),i&&(d*=-1)}const u=l*c*d;for(const t of n)t.x=a.x+(t.x-a.x)*l,t.y=a.y+(t.y-a.y)*c,t.z=a.z+(t.z-a.z)*d;if(e.rotation){const[t,s,i]=e.rotation,r=ot(t),o=ot(s),h=ot(i),l=e.rotationPivot?{x:e.rotationPivot[0],y:e.rotationPivot[1],z:e.rotationPivot[2]}:a;for(const t of n){let e=t.x-l.x,s=t.y-l.y,i=t.z-l.z;if(r){const t=Math.cos(r),e=Math.sin(r),o=s*e+i*t;s=s*t-i*e,i=o}if(o){const t=Math.cos(o),s=Math.sin(o),r=-e*s+i*t;e=e*t+i*s,i=r}if(h){const t=Math.cos(h),i=Math.sin(h),r=e*i+s*t;e=e*t-s*i,s=r}t.x=e+l.x,t.y=s+l.y,t.z=i+l.z}}if(e.position){const[t,s,i]=e.position;for(const e of n)e.x+=t,e.y+=s,e.z+=i}return u<0&&n.reverse(),j.Create(n.map((t=>h.Az.ToArray(t))))}(j.Create(t.points),e);s.orientation=0;const i=s.normals.getAsArray(),r=[0,0,0];for(let t=0;t<i.length;t++)r[0]+=i[t].x,r[1]+=i[t].y,r[2]+=i[t].z;r[0]/=i.length,r[1]/=i.length,r[2]/=i.length;const o=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);0!==o&&(r[0]/=o,r[1]/=o,r[2]/=o);const n=function(t){const[e,s,i]=t;let r=-1/0,o=[0,0,0];for(const t of[-1,0,1])for(const n of[-1,0,1])for(const a of[-1,0,1]){if(0===t&&0===n&&0===a)continue;const h=(e*t+s*n+i*a)/Math.sqrt(t*t+n*n+a*a);h>r&&(r=h,o=[t,n,a])}const n=Math.sqrt(o[0]*o[0]+o[1]*o[1]+o[2]*o[2]);return[o[0]/n,o[1]/n,o[2]/n]}(r);let a=b.Up;return 1==n[0]&&(a=b.East),-1==n[0]&&(a=b.West),1==n[1]&&(a=b.Up),-1==n[1]&&(a=b.Down),1==n[2]&&(a=b.North),-1==n[2]&&(a=b.South),{quad:s,vertexWeights:F(s,a),closestFace:a,quadBounds:H(s.positions.getAsArray().map((t=>h.Az.ToArray(t))))}}const at=rt.ArgIndexes;class ht extends v{quad;quadBounds=[[0,0,0],[0,0,0]];vertexWeights;worldLight;worldAO;closestFace;lightData=new S.$;init(){this.faceCount=6,this.vertexCount=4*this.faceCount;const{quad:t,quadBounds:e,closestFace:s,vertexWeights:i}=nt(this.data,this.transform);this.quad=t,this.quadBounds=e,this.vertexWeights=i,this.closestFace=s}isExposed(){const t=this.faceIndex,e=this.geomtry.faceCullMap[t];if(!e)return!0;const s=this.tool;for(let i=0;i<e.length;i++){const r=e[i],o=c[r],n=yt.getHash(s.nVoxel,s.position.x+o[0],s.position.y+o[1],s.position.z+o[2]),a=yt.space.getGeomtry(n),h=yt.space.getConditionalGeomtry(n);if(a)for(let e=0;e<a.length;e++){const s=this.geomtry.cullIndex.getValue(a[e],r,t);if(s>-1&&!yt.space.getConstructor(n)?.isShapeStateFaceTransparent(yt.space.modCache[n],yt.space.stateCache[n],a[e],s))return!1}if(h)for(let e=0;e<h.length;e++){const s=h[e];for(let i=0;i<s.length;i++){const o=this.geomtry.cullIndex.getValue(s[i],r,t);if(o>-1&&!yt.space.getConstructor(n)?.isCondtionalStateFaceTransparent(yt.space.modCache[n],yt.space.stateCache[n],s[e],o))return!1}}}return!0}determineShading(){const t=this.tool,e=t.lightData[b.Up],s=this.tool.voxel.isLightSource()||this.tool.voxel.noAO(),i=this.worldLight,r=this.worldAO;for(let o=0;o<4;o++){if(r.vertices[o]=0,i.vertices[o]=N(e,this.vertexWeights[o]),s)continue;const n=this.vertexIndex+4+o,a=this.geomtry.vertexHitMap[n];if(a)for(let e=0;e<a.length;e++){const s=a[e],i=c[s],h=yt.getHash(t.nVoxel,t.position.x+i[0],t.position.y+i[1],t.position.z+i[2]);if(1===yt.space.noCastAO[h])continue;const l=yt.space.getGeomtry(h),d=yt.space.getConditionalGeomtry(h);if(!l&&!d)continue;let u=0,f=!1;if(l){u=l.length;for(let t=0;t<u;t++)if(this.geomtry.aoIndex.getValue(l[t],s,n)){r.vertices[o]=1,f=!0;break}}if(d){u=d.length;for(let t=0;t<u;t++){const e=d[t].length;for(let i=0;i<e;i++)if(this.geomtry.aoIndex.getValue(d[t][i],s,n)){r.vertices[o]=1;break}}}}}}shouldFlip(){return!!U(this.worldAO.vertices[0],this.worldAO.vertices[1],this.worldAO.vertices[2],this.worldAO.vertices[3])||U(this.lightData.getS(this.worldLight.vertices[0]),this.lightData.getS(this.worldLight.vertices[1]),this.lightData.getS(this.worldLight.vertices[2]),this.lightData.getS(this.worldLight.vertices[3]))||U(this.lightData.sumRGB(this.worldLight.vertices[0]),this.lightData.sumRGB(this.worldLight.vertices[1]),this.lightData.sumRGB(this.worldLight.vertices[2]),this.lightData.sumRGB(this.worldLight.vertices[3]))}add(t,e,s,i){if(this.tool=t,this.origin=t.position,this.worldAO=t.vars.ao,this.worldLight=t.vars.light,i[at.Enabled]&&this.isExposed()){t.calculateFaceData(this.closestFace),this.determineShading();const e=this.quad;e.flip=this.shouldFlip()||i[at.Fliped],t.vars.textureIndex=i[at.Texture],e.doubleSided=i[at.DoubleSided];const r=i[at.UVs];e.uvs.vertices[0].x=r[0][0],e.uvs.vertices[0].y=r[0][1],e.uvs.vertices[1].x=r[1][0],e.uvs.vertices[1].y=r[1][1],e.uvs.vertices[2].x=r[2][0],e.uvs.vertices[2].y=r[2][1],e.uvs.vertices[3].x=r[3][0],e.uvs.vertices[3].y=r[3][1],tt.addQuad(t,s,e),G(t,s,this.quadBounds)}this.worldLight.setAll(0),this.worldAO.setAll(0)}}const lt=rt.ArgIndexes;class ct extends v{quad;quadBounds=[[0,0,0],[0,0,0]];vertexWeights;worldLight;worldAO;closestFace;lightData=new S.$;init(){this.faceCount=6,this.vertexCount=4*this.faceCount;const{quad:t,closestFace:e,vertexWeights:s,quadBounds:i}=nt(this.data,this.transform);this.quad=t,this.quadBounds=i,this.vertexWeights=s,this.closestFace=e}determineShading(){const t=this.tool.lightData[b.Up],e=(this.tool.voxel.isLightSource()||this.tool.voxel.noAO(),this.worldLight),s=this.worldAO;for(let i=0;i<4;i++)s.vertices[i]=0,e.vertices[i]=N(t,this.vertexWeights[i])}shouldFlip(){return!!U(this.worldAO.vertices[0],this.worldAO.vertices[1],this.worldAO.vertices[2],this.worldAO.vertices[3])||U(this.lightData.getS(this.worldLight.vertices[0]),this.lightData.getS(this.worldLight.vertices[1]),this.lightData.getS(this.worldLight.vertices[2]),this.lightData.getS(this.worldLight.vertices[3]))||U(this.lightData.sumRGB(this.worldLight.vertices[0]),this.lightData.sumRGB(this.worldLight.vertices[1]),this.lightData.sumRGB(this.worldLight.vertices[2]),this.lightData.sumRGB(this.worldLight.vertices[3]))}add(t,e,s,i){if(this.tool=t,this.origin=t.position,this.worldAO=t.vars.ao,this.worldLight=t.vars.light,i[lt.Enabled]){t.calculateFaceData(this.closestFace),this.determineShading();const e=this.quad;e.flip=this.shouldFlip()||i[lt.Fliped],t.vars.textureIndex=i[lt.Texture],e.doubleSided=i[lt.DoubleSided];const r=i[lt.UVs];e.uvs.vertices[0].x=r[0][0],e.uvs.vertices[0].y=r[0][1],e.uvs.vertices[1].x=r[1][0],e.uvs.vertices[1].y=r[1][1],e.uvs.vertices[2].x=r[2][0],e.uvs.vertices[2].y=r[2][1],e.uvs.vertices[3].x=r[3][0],e.uvs.vertices[3].y=r[3][1],tt.addQuad(t,s,e),G(t,s,this.quadBounds)}this.worldLight.setAll(0),this.worldAO.setAll(0)}}const dt=m.ArgIndexes;class ut extends v{quads;quadBounds=[];vertexWeights;worldLight;worldAO;lightData=new S.$;init(){this.faceCount=6,this.vertexCount=4*this.faceCount;const{quads:t,vertexWeights:e,quadBounds:s}=Y(this.data.points,this.transform);this.quads=t,this.quadBounds=s,this.vertexWeights=e}determineShading(t){const e=this.tool.lightData[t],s=(this.tool.voxel.isLightSource()||this.tool.voxel.noAO(),this.worldLight),i=this.worldAO;for(let r=0;r<4;r++)i.vertices[r]=0,s.vertices[r]=N(e,this.vertexWeights[t][r])}shouldFlip(){return!!U(this.worldAO.vertices[0],this.worldAO.vertices[1],this.worldAO.vertices[2],this.worldAO.vertices[3])||U(this.lightData.getS(this.worldLight.vertices[0]),this.lightData.getS(this.worldLight.vertices[1]),this.lightData.getS(this.worldLight.vertices[2]),this.lightData.getS(this.worldLight.vertices[3]))||U(this.lightData.sumRGB(this.worldLight.vertices[0]),this.lightData.sumRGB(this.worldLight.vertices[1]),this.lightData.sumRGB(this.worldLight.vertices[2]),this.lightData.sumRGB(this.worldLight.vertices[3]))}add(t,e,s,i){this.tool=t,this.origin=t.position,this.worldAO=t.vars.ao,this.worldLight=t.vars.light;for(let e=0;e<6;e++)if(i[e][dt.Enabled]){t.calculateFaceData(e),this.determineShading(e);const r=i[e],o=this.quads[e];o.flip=this.shouldFlip()||r[dt.Fliped],t.vars.textureIndex=r[dt.Texture];const n=r[dt.UVs];o.uvs.vertices[0].x=n[0][0],o.uvs.vertices[0].y=n[0][1],o.uvs.vertices[1].x=n[1][0],o.uvs.vertices[1].y=n[1][1],o.uvs.vertices[2].x=n[2][0],o.uvs.vertices[2].y=n[2][1],o.uvs.vertices[3].x=n[3][0],o.uvs.vertices[3].y=n[3][1],tt.addQuad(t,s,o),G(t,s,this.quadBounds[e])}this.worldLight.setAll(0),this.worldAO.setAll(0)}}class ft{geometryPaletteId;nodes=[];faceCullMap;vertexHitMap;cullIndex;aoIndex;constructor(t,e){this.geometryPaletteId=t;for(const s of e.nodes)if("custom"==s.node.type){const e=new(gt.getCustomNode(s.node.id))(t,this,s.node,s.tranform);e.init(),this.nodes.push(e)}if(e?.ruleless)for(const s of e.nodes){if("box"==s.node.type){const e=new ut(t,this,s.node,s.tranform);e.init(),this.nodes.push(e)}if("quad"==s.node.type){const e=new ct(t,this,s.node,s.tranform);e.init(),this.nodes.push(e)}}else{this.faceCullMap=e.faceCullMap,this.vertexHitMap=e.vertexHitMap,this.cullIndex=new d(e.cullIndex),this.aoIndex=new g(e.aoIndex);for(const s of e.nodes){if("box"==s.node.type){const e=new st(t,this,s.node,s.tranform);e.init(),this.nodes.push(e)}if("quad"==s.node.type){const e=new ht(t,this,s.node,s.tranform);e.init(),this.nodes.push(e)}}}let s=0,i=0;for(const t of this.nodes)t.faceIndex=s,t.vertexIndex=i,s+=t.faceCount-1,i+=t.vertexCount}}class gt{static geometryPalette;static geometry=[];static rulesless=[];static setGeometryPalette(t){this.geometryPalette=new a.N(t)}static modelData=new Map;static customNodes=new Map;static registerModels(t){t.forEach((t=>this.modelData.set(t.id,t)))}static registerCustomNode(t,e){this.customNodes.set(t,e)}static getCustomNode(t){const e=this.customNodes.get(t);if(!e)throw new Error(`Custom geometry node [${t}] does not exist.`);return e}static constructorsPaltte=[];static constructors=new Map;static getConstructor(t){return this.constructors.get(t)}static registerVoxel(t){if(Array.isArray(t))for(const e of t)this.constructors.set(e.id,e),this.constructorsPaltte[n.O.ids.getNumberId(e.id)]=e;else this.constructorsPaltte[n.O.ids.getNumberId(t.id)]=t,this.constructors.set(t.id,t)}static registerGeometry(t){for(const e of t){const t=this.geometryPalette.getNumberId(e.id);this.geometry[t]=new ft(t,e),1==e.ruleless?this.rulesless[t]=!0:this.rulesless[t]=!1}}}var pt=s(6774),mt=s(17480);class vt{bounds;foundHash;voxelHash;modCache;stateCache;conditonalStateCache;noCastAO;offset=[0,0,0];constructor(t){this.bounds=t;const e=t.x*t.y*t.z;this.foundHash=new Uint8Array(e),this.voxelHash=new Uint16Array(e),this.modCache=new Int32Array(e),this.stateCache=new Int32Array(e),this.conditonalStateCache=new Int32Array(e),this.noCastAO=new Uint8Array(e)}start(t,e,s){this.offset[0]=t,this.offset[1]=e,this.offset[2]=s,this.foundHash.fill(0),this.conditonalStateCache.fill(-1),this.stateCache.fill(-1),this.modCache.fill(-1)}getIndex(t,e,s){return(0,mt.BN)(t-this.offset[0],e-this.offset[1],s-this.offset[2],this.bounds.x,this.bounds.y,this.bounds.z)}getConstructor(t){return 2!==this.foundHash[t]?null:gt.constructorsPaltte[this.voxelHash[t]]}getGeomtry(t){return 2===this.foundHash[t]&&gt.constructorsPaltte[this.voxelHash[t]].data.shapeStateGeometryMap[this.stateCache[t]]}getConditionalGeomtry(t){return 2===this.foundHash[t]&&gt.constructorsPaltte[this.voxelHash[t]].data.condiotnalShapeStateGeometryMap[this.conditonalStateCache[t]]}}class yt{static space=null;static voxelCursor=new pt.x;static createSpace(t,e,s){return new vt({x:t,y:e,z:s})}static init(){}static start(t){this.space=t}static isRulesless(t){return 1==gt.rulesless[t]}static stop(){}static getHash(t,e,s,i){if(!this.space)throw new Error("Voxel geomtry look up must have space set");const r=this.space?.getIndex(e,s,i);return 0==this.space.foundHash[r]&&this.hashState(t,r,e,s,i),r}static hashState(t,e,s,i,r){if(!this.space)throw new Error("Voxel geomtry look up must have space set");if(2==this.space.foundHash[e])return this.space.stateCache[e];const o=t.getVoxel(s,i,r);if(!o)return this.space.foundHash[e]=1,-1;if(!o.isRenderable())return this.space.foundHash[e]=1,-1;const n=gt.constructorsPaltte[o.getId()];if(this.space.voxelHash[e]=o.getId(),!n||!n.isModel)return this.space.foundHash[e]=1,-1;this.space.foundHash[e]=2,this.space.noCastAO[e]=o.isLightSource()||o.noAO()?1:0;const a=o.getState(),h=n.shapeStateTree.getState(a);this.space.stateCache[e]=h;const l=o.getMod(),c=n.modTree.getState(l);this.space.modCache[e]=c,this.voxelCursor.copy(o).process(),n.schema.position.x=s,n.schema.position.y=i,n.schema.position.z=r,n.schema.voxel=this.voxelCursor,n.schema.dataCursor=t;const d=n.condtioanlShapeStateTree.getState();return this.space.conditonalStateCache[e]=d,h}}var xt=s(23917),At=s(33329),bt=s(56964),wt=s(71657),It=s(50433),St=s(91704),Tt=s(15620),_t=s(60445),zt=s(5268),Lt=s(67768),Bt=s(47464);class Ct{static _brush=new Lt.l;static _sDataTool=new Bt.pM;static _nDataTool=new Bt.pM;static _substanceTool=new Tt.j;static setVoxel(t,e,s,i,r,o,n){}static setDimension(t){}static removeVoxel(t,e,s,i){}static getFlowRate(t){return this._substanceTool.setSubstanceFromString(t),this._substanceTool.getFlowRate()}static getVoxel(t,e,s){return this._sDataTool}static setLevel(t,e,s,i){}static getLevel(t,e,s,i){}static getLevelState(t,e,s,i){}static canFlowOutwardTest(t,e,s,i){}static flowDownTest(t,e,s,i){}static wait(t){return new Promise(((e,s)=>setTimeout(e,t)))}static _lightValues=[0,0,0,0];static getAbsorbLight(t,e,s){}static sunCheck(t,e,s,i){}}async function Rt(t,e=!0){}const Ut=new St.P,Vt=new Tt.j,Mt=t=>{let e=wt.i.doRGBPropagation(),s=wt.i.doSunPropagation();const[i,r,o,n]=t.origin;t.nDataCursor.setFocalPoint(i,r,o,n);for(const i of It.LE){const a=i[0]+r,h=i[1]+o,l=i[2]+n,c=t.nDataCursor.getVoxel(a,h,l);c&&(e&&c.hasRGBLight()&&t.rgb.update.push(a,h,l),s&&c.hasSunLight()&&t.sun.update.push(a,h,l))}};async function Dt(t){const[e,s,i,r]=t;Ut.setOrigin(t);let o=Ut.sDataCursor.getVoxel(s,i,r);if(!o)return!1;if(Vt.setSubstance(o.getSubstance()),!o.isAir()&&wt.i.doFlow()&&o.isRenderable()&&Vt.isLiquid())return async function(){}(),Ut;o=Ut.sDataCursor.getVoxel(s,i,r);const n=o.getLight(),a=o.isLightSource();return o.setSecondary(!0).setId(0).setSecondary(!1),o.setLight(n>0?n:0).setId(0).setLevel(0).setLevelState(0).setState(0).setMod(0).updateHeightMap(1),wt.i.doLight()&&(wt.i.doRGBPropagation()&&a&&(Ut.rgb.remove.push(s,i,r),(0,_t.Q)(Ut)),Mt(Ut),wt.i.doRGBPropagation()&&(0,_t.D)(Ut),wt.i.doSunPropagation()&&(0,zt.a)(Ut)),Ut}async function kt(t){const[e,s,i,r]=t[0];Ut.setOrigin(t[0]);let o=Ut.sDataCursor.getVoxel(s,i,r);if(!o)return!1;const n=t[1],a=o.isOpaque();let h=wt.i.doRGBPropagation(),l=wt.i.doSunPropagation();t:if(wt.i.doLight()){if(o.getLight()<=0)break t;l&&o.hasSunLight()&&(Ut.sun.remove.push(s,i,r),(0,zt.z)(Ut)),h&&o.hasRGBLight()&&a&&(Ut.rgb.remove.push(s,i,r),(0,_t.Q)(Ut))}o=Ut.sDataCursor.getVoxel(s,i,r);const c=n[0];return!(c<0)&&(o.setId(c),o.setState(n[2]),o.getSubstance()>-1&&!o.isAir()&&Vt.setSubstance(o.getSubstance()).isLiquid()&&o.setLevel(7),o.setMod(n[4]),n[3]>0&&o.canHaveSecondaryVoxel()&&(o.setSecondary(!0),o.setId(n[3]),o.setSecondary(!1)),o.isLightSource()&&o.getLightSourceValue()&&o.setLight(o.getLightSourceValue()),o.updateHeightMap(0),wt.i.doLight()&&(Mt(Ut),h&&(Ut.rgb.update.push(s,i,r),(0,_t.D)(Ut)),l&&(0,zt.a)(Ut)),o=Ut.sDataCursor.getVoxel(s,i,r),wt.i.doFlow()&&!o.isAir()&&Vt.setSubstance(o.getSubstance()).isLiquid()&&Rt(),Ut)}async function Pt(t){const[e,s,i,r]=t[0];Ut.setOrigin(t[0]);const o=Ut.sDataCursor.getVoxel(s,i,r);if(!o)return!1;let n=wt.i.doRGBPropagation(),a=wt.i.doSunPropagation();return wt.i.doLight()&&(Mt(Ut),n&&(Ut.rgb.update.push(s,i,r),(0,_t.D)(Ut)),a&&(Ut.sun.update.push(s,i,r),(0,zt.a)(Ut))),wt.i.doFlow()&&Vt.setSubstance(o.getSubstance()).isLiquid()&&Rt(),Ut}var Et=s(95027),Nt=s(44575),Ft=s(28135);class Ot{static _sectionState;static setSection(t){return this._sectionState||(this._sectionState=Nt.w.StateStruct.instantiate()),this._sectionState.setData(t.sectionState),this}static setVoxel(t,e){this._sectionState[Ft.g.heightMap][t]=e?1:0}static getVoxel(t){return 1==this._sectionState[Ft.g.heightMap][t]}static setDirty(t,e){this._sectionState[Ft.g.dirtyMap][t]=e?1:0}static getDirty(t){return 1==this._sectionState[Ft.g.dirtyMap][t]}static getMinMax(){let t=1/0,e=-1/0,s=Et.k.section.bounds.y;for(;s--;)(this._sectionState[Ft.g.heightMap][s]||this._sectionState[Ft.g.dirtyMap][s])&&(s<t&&(t=s),s>e&&(e=s));return[t,e]}}class Qt{static getRelative(t){t=[...t];const e=Et.k.section.bounds.x,s=Et.k.section.bounds.z;let i=-1/0;const[r,o,n,a]=t;for(const r of It.vY){t[1]=r[0]*e+o,t[3]=r[1]*s+a;const n=this.getAbsolute(t);n>i&&(i=n)}return i}static getAbsolute(t){const e=At._.sectors.get(t[0],t[1],t[2],t[3]);if(!e)return Et.k.world.bounds.MinY;if(0==e.sections.length)return Et.k.world.bounds.MinY;let s=Et.k.world.bounds.MinY,i=[t[1],t[2],t[3]][1];for(let t=0;t<e.sections.length;t++){const r=e.sections[t];if(!r)continue;Ot.setSection(r);const o=i+t*Et.k.section.bounds.y;let[n,a]=Ot.getMinMax();Math.abs(a)!=1/0&&(a=o+a,s<a&&(s=a))}return s+1}}var qt=s(64517);const Wt=[[1,0,0],[-1,0,0],[0,0,1],[0,0,-1],[0,1,0]],jt=[],Gt=new S.$;var Ht=s(69775);class Yt{_map=new Map;get size(){return this._map.size}_getKey(t,e,s){return`${t}_${e}_${s}`}inMap(t,e,s){return this._map.has(this._getKey(t,e,s))}add(t,e,s){this._map.set(this._getKey(t,e,s),!0)}remove(t,e,s){this._map.delete(this._getKey(t,e,s))}removeDiffernce(t){for(const[e]of t._map)this._map.has(e)&&this._map.delete(e);return t}clear(){this._map.clear()}}const Xt=new S.$,$t={runExplosion(t,e){const[s,i,r,o]=t.origin;Ct.setDimension(s);const n=[],a=new Yt;for(n.push([i,r,o]);n.length;){const s=n.shift();if(!s)break;const h=s[0],l=s[1],c=s[2];!a.inMap(h+1,l,c)&&t.sDataCursor.getVoxel(h+1,l,c)&&((0,Ht.D)(i,r,o,h+1,l,c)<=e&&n.push([h+1,l,c]),a.add(h+1,l,c)),a.inMap(h-1,l,c)||(t.sDataCursor.getVoxel(h-1,l,c)&&(0,Ht.D)(i,r,o,h-1,l,c)<=e&&n.push([h-1,l,c]),a.add(h-1,l,c)),a.inMap(h,l,c+1)||(t.sDataCursor.getVoxel(h,l,c+1)&&(0,Ht.D)(i,r,o,h,l,c+1)<=e&&n.push([h,l,c+1]),a.add(h,l,c+1)),a.inMap(h,l,c-1)||(t.sDataCursor.getVoxel(h,l,c-1)&&(0,Ht.D)(i,r,o,h,l,c-1)<=e&&n.push([h,l,c-1]),a.add(h,l,c-1)),a.inMap(h,l+1,c)||(t.sDataCursor.getVoxel(h,l+1,c)&&(0,Ht.D)(i,r,o,h,l+1,c)<=e&&n.push([h,l+1,c]),a.add(h,l+1,c)),a.inMap(h,l-1,c)||(t.sDataCursor.getVoxel(h,l-1,c)&&(0,Ht.D)(i,r,o,h,l-1,c)<=e&&n.push([h,l-1,c]),a.add(h,l-1,c));const d=t.sDataCursor.getVoxel(h,l,c);if(d&&d.isRenderable()){for(const e of It.LE){const s=h+e[0],i=l+e[1],r=c+e[2],o=t.nDataCursor.getVoxel(h,l,c);if(o){const e=o.getLight();e>0&&(Xt.getS(e)>0&&t.sun.remove.push(s,i,r),Xt.hasRGBLight(e)&&t.rgb.remove.push(s,i,r))}}t.bounds.update(h,l,c),d.setAir().updateHeightMap(1)}}(0,_t.Q)(t),(0,zt.z)(t),(0,_t.D)(t),(0,zt.a)(t)}};var Zt=s(28517),Kt=s(98720);class Jt extends Kt.s{_section;voxel=new Zt.$(this);_voxelIndex=0;_voxelPosition=h.Az.Create();_sectionPosition=h.Az.Create();inBounds(t,e,s){const i=this._sectionPosition.x+Et.k.section.bounds.x,r=this._sectionPosition.y+Et.k.section.bounds.y,o=this._sectionPosition.z+Et.k.section.bounds.z;return!(t<this._sectionPosition.x||e<this._sectionPosition.y||s<this._sectionPosition.z||t>i||e>r||s>o)}setSection(t,e,s,i){if("object"==typeof t){this._section=t;const e=this._section.getPosition();return this._sectionPosition.x=e[0],this._sectionPosition.y=e[1],void(this._sectionPosition.z=e[2])}const r=At._.sectors.get(t,e||0,s||0,i||0);if(!r)return!1;this._section=r.getSection(s||0);const o=this._section.getPosition();return this._sectionPosition.x=o[0],this._sectionPosition.y=o[1],this._sectionPosition.z=o[2],!0}getVoxel(t,e,s){return this._section?(this._voxelIndex=Et.k.voxel.getIndex(t,e,s),Et.k.voxel.getPosition(t,e,s,this._voxelPosition),this.voxel.loadIn(),this.voxel):null}}const te=new Jt;new Z;var ee=s(75025);class se{vertexFloatSize;sectorVertexSize;_buffers=[];constructor(t,e,s=4){this.vertexFloatSize=t,this.sectorVertexSize=e;const i=t*e;for(let t=0;t<s;t++)this._buffers.push(new Float32Array(i));const r=this;return new Proxy([],{get:(t,e)=>{if("length"==e)return r.length;if("_buffers"==e)return r._buffers;const s=+e,o=Math.floor(s/i);r._buffers[o]||(this._buffers[o]=new Float32Array(i));const n=s-o*i;return r._buffers[o][n]},set:(t,e,s)=>{if("length"==e)return!1;const o=+e,n=Math.floor(o/i);r._buffers[n]||(r._buffers[n]=new Float32Array(i));const a=o-n*i;return r._buffers[n][a]=s,!0}})}get length(){return this._buffers.length*this.vertexFloatSize}}class ie{sectorSize;_buffers=[];constructor(t,e=4){this.sectorSize=t;for(let s=0;s<e;s++)this._buffers.push(new Uint32Array(t));const s=this;return new Proxy([],{get:(e,i)=>{if("length"==i)return s.length;if("_buffers"==i)return s._buffers;const r=+i,o=Math.floor(r/t);s._buffers[o]||(this._buffers[o]=new Uint32Array(t));const n=r-o*t;return s._buffers[o][n]},set:(e,i,r)=>{if("length"==i)return!1;const o=+i,n=Math.floor(o/t);s._buffers[n]||(s._buffers[n]=new Uint32Array(t));const a=o-n*t;return s._buffers[n][a]=r,!0}})}get length(){return this._buffers.length*this.sectorSize}}class re{indicieIndex=0;indicieCount=0;vertexCount=0;minBounds=h.Az.Create(1/0,1/0,1/0);maxBounds=h.Az.Create(-1/0,-1/0,-1/0);buffer=new se(Z.VertexFloatSize,1e3);indices=new ie(1e3);addVerticies(t,e){this.vertexCount+=t,this.indicieCount+=e}clear(){this.indicieCount=0,this.vertexCount=0,this.minBounds.x=1/0,this.minBounds.y=1/0,this.minBounds.z=1/0,this.maxBounds.x=-1/0,this.maxBounds.y=-1/0,this.maxBounds.z=-1/0}}class oe{segments=new Map;mesh=null;startNewMesh(t){this.mesh=t||new re}resetAll(){return this.mesh?.clear(),this}}const ne=new S.$,ae=new Uint16Array([0,0,0,0]),he=new Uint16Array([0,0,0,0]),le={doAO:!0,doLight:!0},ce={settings:le,calculate(t,e){let s=e.voxel.getLight();const i=I[t],r=e.nVoxel.getVoxel(e.position.x+i[0],e.position.y+i[1],e.position.z+i[2]),o=r?.getLight()||0;s=o>=0?o:s>=0?s:0;for(let i=0;i<4;i++){le.doLight&&(e.lightData[t][i]=s,ne.getLightValuesToRef(s,ae));for(let s=0;s<9;s+=3){const r=e.nVoxel.getVoxel(_[t][i][s]+e.position.x,_[t][i][s+1]+e.position.y,_[t][i][s+2]+e.position.z);if(!le.doLight||!r)continue;const o=r.getLight();o<=0||(ne.getLightValuesToRef(o,he),ae[0]=ae[0]<he[0]?he[0]:ae[0],ae[1]=ae[1]<he[1]?he[1]:ae[1],ae[2]=ae[2]<he[2]?he[2]:ae[2],ae[3]=ae[3]<he[3]?he[3]:ae[3])}e.lightData[t][i]=ne.setLightValues(ae)}}};class de{faceFlipped=!1;textureIndex=0;light=new W;ao=new W;animation=new W;level=new W;overlayTextures=new W;reset(){this.faceFlipped=!1,this.textureIndex=0}}class ue extends oe{id;materialIndex;voxel;nVoxel;position=h.Az.Create();origin=h.Az.Create();mesh=new re;bvhTool=null;vars=new de;dataCalculated;condiotnalGeometryData;lightData;effects;constructor(t,e){super(),this.id=t,this.materialIndex=e,this.dataCalculated=[];for(const t of w)this.dataCalculated[t]=!1;this.condiotnalGeometryData=[];for(const t of w)this.condiotnalGeometryData[t]=[],this.condiotnalGeometryData[t][y.TopRight]=[[],[],[]],this.condiotnalGeometryData[t][y.TopLeft]=[[],[],[]],this.condiotnalGeometryData[t][y.BottomLeft]=[[],[],[]],this.condiotnalGeometryData[t][y.BottomRight]=[[],[],[]];this.lightData=[];for(const t of w)this.lightData[t]=[],this.lightData[t][y.TopRight]=0,this.lightData[t][y.TopLeft]=0,this.lightData[t][y.BottomLeft]=0,this.lightData[t][y.BottomRight]=0;this.startNewMesh(new re)}bounds={min:[0,0,0],max:[0,0,0]};_indexStart=0;startConstruction(){this._indexStart=this.mesh.indices.length,this.bounds.min[0]=1/0,this.bounds.min[1]=1/0,this.bounds.min[2]=1/0,this.bounds.max[0]=-1/0,this.bounds.max[1]=-1/0,this.bounds.max[2]=-1/0}endConstruction(){return!this.bounds.min.includes(1/0)&&!this.bounds.max.includes(-1/0)&&(this.bvhTool&&this.bvhTool.updateVoxel(this.position.x,this.position.y,this.position.z,this._indexStart,this.materialIndex,this.mesh.indices.length,this.bounds.min[0],this.bounds.min[1],this.bounds.min[2],this.bounds.max[0],this.bounds.max[1],this.bounds.max[2]),!0)}calculateFaceData(t){if(this.dataCalculated[t])return!0;ce.calculate(t,this),this.dataCalculated[t]=!0}clearCalculatedData(){this.dataCalculated[b.Up]=!1,this.dataCalculated[b.Down]=!1,this.dataCalculated[b.North]=!1,this.dataCalculated[b.South]=!1,this.dataCalculated[b.East]=!1,this.dataCalculated[b.West]=!1}reset(){this.vars.reset()}}class fe{static meshersMap=new Map;static meshers=[];static register(t){for(let e=0;e<t.length;e++){const s=new ue(t[e],e);this.meshersMap.set(t[e],s),this.meshers[e]=s}}}const ge=new Float32Array([1/0])[0];class pe{levels;constructor(t){this.levels=t}getLevelSize(t){if(t<0||t>=this.levels)throw new Error("Invalid level");return 1<<t}getIndexAtLevel(t,e){if(t<0||t>=this.levels)throw new Error("Invalid level");const s=this.getLevelSize(t);if(e<0||e>=s)throw new Error("Invalid node index at the given level");return(1<<t)-1+e}getLevelAndIndex(t){const e=(1<<this.levels)-1;if(t<0||t>=e)throw new Error("Invalid node index");const s=Math.floor(Math.log2(t+1));return[s,t-((1<<s)-1)]}getLeftChildAtLevel(t,e){if(t+1>=this.levels)return-1;const s=this.getIndexAtLevel(t,e);return this.getLeftChild(s)}getRightChildAtLevel(t,e){if(t+1>=this.levels)return-1;const s=this.getIndexAtLevel(t,e);return this.getRightChild(s)}getParentAtLevel(t,e){if(0===t)return-1;const s=this.getIndexAtLevel(t,e);return this.getParent(s)}getLeftChild(t){const e=2*t+1;return e<(1<<this.levels)-1?e:-1}getRightChild(t){const e=2*t+2;return e<(1<<this.levels)-1?e:-1}getParent(t){return 0===t?-1:Math.floor((t-1)/2)}getTotalSize(){return(1<<this.levels)-1}}class me{data;get minX(){return this.data[this.trueIndex]}get minY(){return this.data[this.trueIndex+1]}get minZ(){return this.data[this.trueIndex+2]}get maxX(){return this.data[this.trueIndex+4]}get maxY(){return this.data[this.trueIndex+5]}get maxZ(){return this.data[this.trueIndex+6]}get voxelIndex(){return this.data[this.trueIndex+3]}get active(){return this.data[this.trueIndex+3]}get nodeType(){return this.data[this.trueIndex+7]}trueIndex=0;_index=0;get index(){return this._index}set index(t){this._index=t,this.trueIndex=8*t}constructor(t){this.data=t}setActive(){this.data[this.trueIndex+3]=1}setVoxelIndex(t){this.data[this.trueIndex+3]=t}setInnerNode(){this.data[this.trueIndex+7]=1}setGeomtryNode(){this.data[this.trueIndex+7]=2}updateMin(t,e,s){const i=this.trueIndex,r=this.trueIndex+1,o=this.trueIndex+2;(t<this.data[i]||this.data[i]==-ge)&&(this.data[i]=t),(e<this.data[r]||this.data[r]==-ge)&&(this.data[r]=e),(s<this.data[o]||this.data[o]==-ge)&&(this.data[o]=s)}updateMax(t,e,s){const i=this.trueIndex+4,r=this.trueIndex+5,o=this.trueIndex+6;(t>this.data[i]||this.data[i]==-ge)&&(this.data[i]=t),(e>this.data[r]||this.data[r]==-ge)&&(this.data[r]=e),(s>this.data[o]||this.data[o]==-ge)&&(this.data[o]=s)}toJSON(){return{min:[this.minX,this.minY,this.minZ],max:[this.maxX,this.maxY,this.maxZ],active:this.active,nodeType:this.nodeType}}}class ve{static AABBStructByteSize=32;treeIndex=new pe(13);tree=new Float32Array(new ArrayBuffer(this.treeIndex.getTotalSize()*ve.AABBStructByteSize));structCursor=new me(this.tree);indices=new Uint32Array(2*this.treeIndex.getLevelSize(12));reset(){this.tree.fill(-ge),this.indices.fill(0)}updateVoxel(t,e,s,i,r,o,n,a,h,l,c,d){const u=Et.k.voxel.getIndex(t,e,s),f=this.treeIndex.getIndexAtLevel(12,u);this.indices[2*u]=r,this.indices[2*u+1]=o,this.structCursor.index=f,this.structCursor.updateMin(n,a,h),this.structCursor.updateMax(l,c,d),this.structCursor.setVoxelIndex(u),this.structCursor.setGeomtryNode();let g=f;for(let t=1;t<13;t++){let t=this.treeIndex.getParent(g);this.structCursor.index=t,this.structCursor.updateMin(n,a,h),this.structCursor.updateMax(l,c,d),this.structCursor.setActive(),this.structCursor.setInnerNode(),g=t}}}const ye=new Jt,xe=new ee.p;let Ae;const be=new ve;function we(t,e,s){const i=ye.getVoxel(t,e,s);return!!i&&!!i.isRenderable()&&(i.hasSecondaryVoxel()&&(i.setSecondary(!0),Ie(t,e,s,i),i.setSecondary(!1)),Ie(t,e,s,i),!0)}function Ie(t,e,s,i){const r=gt.constructorsPaltte[i.getId()];if(!r)throw new Error(`Could not find constructor ${i.getId()} | ${i.getName()} `);const o=fe.meshers[i.getRenderedMaterial()];if(!o)throw new Error(`Could not find material for ${i.getId()} | ${i.getName()} | ${r?.id} | ${i.getMaterial()} | ${i.getRenderedMaterialStringId()}`);o.origin.x=ye._voxelPosition.x,o.origin.y=ye._voxelPosition.y,o.origin.z=ye._voxelPosition.z,o.position.x=t,o.position.y=e,o.position.z=s,o.voxel=i,o.nVoxel=xe,o.startConstruction(),r.process(o),o.endConstruction(),o.reset()}const Se=h.Az.Create(5,5,5);function Te(t){Ae||(Ae=yt.createSpace(Et.k.section.bounds.x+Se.x,Et.k.section.bounds.y+Se.y,Et.k.section.bounds.z+Se.z));const[e,s,i,r]=t,o=At._.sectors.get(e,s,i,r);if(!o)return null;const n=o.getSection(i);Ot.setSection(n),xe.setFocalPoint(...t),ye.setSection(...t);let[a,h]=Ot.getMinMax();const l=Et.k.section.bounds.x,c=Et.k.section.bounds.z;if(Math.abs(a)==1/0&&Math.abs(h)==1/0)return null;Ae.start(s-Se.x,i-Se.y,r-Se.z),yt.start(Ae),be.reset();for(let t=0;t<fe.meshers.length;t++)fe.meshers[t].bvhTool=be;for(let t=a;t<=h;t++){let e=!1;if(Ot.getVoxel(t)||Ot.getDirty(t)){for(let o=0;o<l;o++)for(let n=0;n<c;n++)we(o+s,t+i,n+r)&&(e=!0);Ot.setVoxel(t,e),Ot.setDirty(t,!1)}}yt.stop();const d=[],u=[],f=[t,[],u,0],g=[];for(let t=0;t<fe.meshers.length;t++){const e=fe.meshers[t];for(const t in e.effects){const s=Float32Array.from(e.effects[t]);d.push(s.buffer),u.push([t,s])}e.mesh.vertexCount?g.push(e):(e.resetAll(),e.bvhTool=null)}const[p,m]=function(t){const e=[0,[]],s=[];for(let i=0;i<t.length;i++){const r=t[i];if(!r.mesh.buffer.length)continue;const o=r.mesh.vertexCount*Z.VertexFloatSize,n=new Float32Array(o),a=r.mesh.buffer._buffers;let h=0,l=!1;for(let t=0;t<a.length;t++){const e=a[t];for(let t=0;t<e.length;t++)if(n[h]=e[t],h++,h>o){l=!0;break}if(l)break}const c=r.mesh.indicieCount>65535?new Uint32Array(r.mesh.indicieCount):new Uint16Array(r.mesh.indicieCount),d=r.mesh.indices._buffers;h=0,l=!1;for(let t=0;t<d.length;t++){const e=d[t];for(let t=0;t<e.length;t++)if(c[h]=e[t],h++,h>r.mesh.indicieCount){l=!0;break}if(l)break}const u=r.mesh.minBounds,f=r.mesh.maxBounds;e[1].push([r.id,n,c,[u.x,u.y,u.z],[f.x,f.y,f.z]]),s.push(n.buffer,c.buffer)}return[e,s]}(g);f[1]=p;for(let t=0;t<g.length;t++)g[t].resetAll(),g[t].bvhTool=null;return[f,[...d,...m]]}var _e,ze,Le=s(3649),Be=s(96715);!function(t){t[t.None=0]="None",t[t.Down=1]="Down",t[t.Up=2]="Up"}(_e||(_e={})),function(t){t[t.NorthEast=0]="NorthEast",t[t.NorthWest=1]="NorthWest",t[t.SouthWest=2]="SouthWest",t[t.SouthEsat=3]="SouthEsat"}(ze||(ze={}));const Ce={[ze.NorthEast]:[1,0,0,1,1,1],[ze.NorthWest]:[-1,0,0,1,-1,1],[ze.SouthWest]:[-1,0,0,-1,-1,-1],[ze.SouthEsat]:[1,0,0,-1,1,-1]};function Re(t,e,s,i){const r=t.nVoxel.getVoxel(e,s,i);if(!r||!r.isRenderable())return-1;if(!t.voxel.isSameVoxel(r))return-1;const o=r.getLevel();return r.getLevelState()>0?7:o}const Ue=[h.xH.East,0],Ve=new W,Me=new W,De=new S.$,ke=6/7,Pe={[h.xH.North]:j.RotateUvs(j.FullUVs,h.xH.North),[h.xH.South]:j.RotateUvs(j.FullUVs,h.xH.South),[h.xH.East]:j.RotateUvs(j.FullUVs,h.xH.East),[h.xH.West]:j.RotateUvs(j.FullUVs,h.xH.West),[h.xH.NorthWest]:j.RotateUvs(j.FullUVs,h.xH.NorthWest),[h.xH.NorthEast]:j.RotateUvs(j.FullUVs,h.xH.NorthEast),[h.xH.SouthWest]:j.RotateUvs(j.FullUVs,h.xH.SouthWest),[h.xH.SouthEast]:j.RotateUvs(j.FullUVs,h.xH.SouthEast)},Ee=[[1,1],[0,1],[0,0],[1,0]],{quads:Ne,vertexWeights:Fe,quadBounds:Oe}=Y([[0,0,0],[1,ke,1]]);Ne[b.Up].setUVs(Ee),Ne[b.Down].setUVs(Ee);class Qe extends v{worldLight;init(){this.faceCount=1,this.vertexCount=0}isExposed(t){const e=this.tool.nVoxel.getVoxel(I[t][0]+this.tool.position.x,I[t][1]+this.tool.position.y,I[t][2]+this.tool.position.z);return!(e&&!e.isAir()&&(this.tool.voxel.isSameVoxel(e)||t!=b.Up))}determineShading(t){const e=this.tool.lightData[t],s=this.worldLight;for(let t=0;t<4;t++)s.vertices[t]=e[t]}shouldFlip(){return U(De.getS(this.worldLight.vertices[0]),De.getS(this.worldLight.vertices[1]),De.getS(this.worldLight.vertices[2]),De.getS(this.worldLight.vertices[3]))||U(De.sumRGB(this.worldLight.vertices[0]),De.sumRGB(this.worldLight.vertices[1]),De.sumRGB(this.worldLight.vertices[2]),De.sumRGB(this.worldLight.vertices[3]))}add(t,e,s,i){Me.setAll(15),Ve.setAll(0),this.tool=t,this.tool=t,this.origin=t.position,this.worldLight=t.vars.light;let r=!1;if(this.isExposed(b.Up)){r=!0,function(t,e){const s=t.voxel.getLevel(),i=t.voxel.getLevelState();for(let r=0;r<=3;r++){const o=Ce[r];let n=s,a=0;for(let s=0;s<6;s+=2){const i=o[s]+t.position.x,h=o[s+1]+t.position.z;if(Re(t,i,t.position.y+1,h)>0){e.vertices[r]=9,n=9;break}const l=Re(t,i,t.position.y,h);-1==l&&a++,n<l&&(n=l)}(n<7&&n>3||1==i)&&a>=2&&(n=3),e.vertices[r]=n}}(t,Me);const e=Ne[b.Up];t.calculateFaceData(b.Up),this.determineShading(b.Up),e.flip=this.shouldFlip(),t.vars.textureIndex=i.stillTexture,Ve.set(Me.vertices[0]/7,Me.vertices[1]/7,Me.vertices[2]/7,Me.vertices[3]/7);const o=function(t){if(t.isAllEqualTo(7))return Ue[0]=0,Ue[1]=_e.None,Ue;const e=t.vertices[y.TopRight],s=t.vertices[y.TopLeft],i=t.vertices[y.BottomLeft],r=t.vertices[y.BottomRight],o=e==r,n=s==i;if(e==s&&r==i){if(e<r)return Ue[0]=h.xH.North,Ue[1]=_e.Up,Ue;if(e>r)return Ue[0]=h.xH.South,Ue[1]=_e.Up,Ue}if(o&&n){if(e<s)return Ue[0]=h.xH.East,Ue[1]=_e.Up,Ue;if(e>s)return Ue[0]=h.xH.West,Ue[1]=_e.Up,Ue}return r<e&&r<s&&r<i||s>e&&s>r&&s>i?(Ue[0]=h.xH.SouthEast,Ue[1]=_e.Up,Ue):s<e&&s<r&&s<i||r>e&&r>s&&r>i?(Ue[0]=h.xH.NorthWest,Ue[1]=_e.Up,Ue):e<r&&e<s&&e<i||i>r&&i>s&&i>e?(Ue[0]=h.xH.NorthEast,Ue[1]=_e.Up,Ue):i<r&&i<s&&i<e||e>r&&e>s&&e>i?(Ue[0]=h.xH.SouthWest,Ue[1]=_e.Up,Ue):(Ue[0]=h.xH.North,Ue[1]=_e.Up,Ue)}(Me),n=Pe[o[0]];t.vars.animation.setAll(o[1]),e.uvs.vertices[y.TopRight].x=n[0][0],e.uvs.vertices[y.TopRight].y=n[0][1],e.uvs.vertices[y.TopLeft].x=n[1][0],e.uvs.vertices[y.TopLeft].y=n[1][1],e.uvs.vertices[y.BottomLeft].x=n[2][0],e.uvs.vertices[y.BottomLeft].y=n[2][1],e.uvs.vertices[y.BottomRight].x=n[3][0],e.uvs.vertices[y.BottomRight].y=n[3][1],e.positions.vertices[0].y=Ve.vertices[0]*ke,e.positions.vertices[1].y=Ve.vertices[1]*ke,e.positions.vertices[2].y=Ve.vertices[2]*ke,e.positions.vertices[3].y=Ve.vertices[3]*ke,tt.addQuad(t,s,e),G(t,s,Oe[b.Up])}if(this.isExposed(b.Down)){t.vars.textureIndex=i.stillTexture;const e=Ne[b.Down];t.calculateFaceData(b.Down),this.determineShading(b.Down),e.flip=this.shouldFlip(),t.vars.textureIndex=i.stillTexture,tt.addQuad(t,s,e),G(t,s,Oe[b.Down])}if(this.isExposed(b.North)){t.vars.textureIndex=i.stillTexture;const e=Ne[b.North];t.vars.animation.setAll(1),t.calculateFaceData(b.North),this.determineShading(b.North),e.flip=this.shouldFlip(),r?(e.positions.vertices[y.TopRight].y=Ve.vertices[ze.NorthWest]*ke,e.positions.vertices[y.TopLeft].y=Ve.vertices[ze.NorthEast]*ke,e.uvs.vertices[y.TopRight].y=Ve.vertices[ze.NorthWest],e.uvs.vertices[y.TopLeft].y=Ve.vertices[ze.NorthEast]):(e.positions.vertices[y.TopRight].y=1,e.positions.vertices[y.TopLeft].y=1,e.setUVs(Ee)),tt.addQuad(t,s,e),G(t,s,Oe[b.North])}if(this.isExposed(b.South)){t.vars.textureIndex=i.stillTexture;const e=Ne[b.South];t.vars.animation.setAll(1),t.calculateFaceData(b.South),this.determineShading(b.South),e.flip=this.shouldFlip(),r?(e.positions.vertices[y.TopRight].y=Ve.vertices[ze.SouthEsat]*ke,e.positions.vertices[y.TopLeft].y=Ve.vertices[ze.SouthWest]*ke,e.uvs.vertices[y.TopRight].y=Ve.vertices[ze.SouthEsat],e.uvs.vertices[y.TopLeft].y=Ve.vertices[ze.SouthWest]):(e.positions.vertices[y.TopLeft].y=1,e.positions.vertices[y.TopRight].y=1,e.setUVs(Ee)),tt.addQuad(t,s,e),G(t,s,Oe[b.South])}if(this.isExposed(b.East)){t.vars.textureIndex=i.stillTexture;const e=Ne[b.East];t.vars.animation.setAll(1),t.calculateFaceData(b.East),this.determineShading(b.East),r?(e.positions.vertices[y.TopRight].y=Ve.vertices[ze.NorthEast]*ke,e.positions.vertices[y.TopLeft].y=Ve.vertices[ze.SouthEsat]*ke,e.uvs.vertices[y.TopRight].y=Ve.vertices[ze.SouthEsat],e.uvs.vertices[y.TopLeft].y=Ve.vertices[ze.NorthEast]):(e.positions.vertices[y.TopLeft].y=1,e.positions.vertices[y.TopRight].y=1,e.setUVs(Ee)),tt.addQuad(t,s,e),G(t,s,Oe[b.East])}if(this.isExposed(b.West)){t.vars.textureIndex=i.stillTexture;const e=Ne[b.West];t.vars.animation.setAll(1),t.calculateFaceData(b.West),this.determineShading(b.West),e.flip=this.shouldFlip(),r?(e.positions.vertices[y.TopRight].y=Ve.vertices[ze.SouthWest]*ke,e.positions.vertices[y.TopLeft].y=Ve.vertices[ze.NorthWest]*ke,e.uvs.vertices[y.TopRight].y=Ve.vertices[ze.SouthWest],e.uvs.vertices[y.TopLeft].y=Ve.vertices[ze.NorthWest]):(e.positions.vertices[y.TopLeft].y=1,e.positions.vertices[y.TopRight].y=1,e.setUVs(Ee)),tt.addQuad(t,s,e),G(t,s,Oe[b.West])}this.worldLight.setAll(0)}}var qe,We,je=s(83841),Ge=s(65881),He=s(40397),Ye=s(30169);class Xe{data;view;constructor(t){this.data=t,this.view=new DataView(t.buffer)}getValue(t,e,s){return f.u.getBitArrayIndex(this.view,this.data.resultsSize*t+e,s)}setValue(t,e,s,i=1){f.u.setBitArrayIndex(this.view,this.data.resultsSize*t+e,s,i)}}class $e{model;effects=[];constructor(t){this.model=t;for(const e of t.data.effects)"fx-points"==e.type&&this.effects.push({id:e.effectId,reader:new Ye.z(t.schema,0,e.tree),palette:e.treePalette})}addEffects(t,e,s){if(this.effects.length)for(let i=0;i<this.effects.length;i++){const r=this.effects[i];let o=s[r.id];o||(o=[],s[r.id]=o);const n=r.reader.getState(t);if(-1==n)continue;const a=r.palette[n];if(!a)continue;let h=o.length;for(let t=0;t<a.length;t++){const s=a[t];o[h]=e.x+s[0],o[h+1]=e.y+s[1],o[h+2]=e.z+s[2],h+=3}}}}!function(t){t[t.Equals=0]="Equals",t[t.NotEquals=1]="NotEquals",t[t.GreaterThan=2]="GreaterThan",t[t.LessThan=3]="LessThan"}(qe||(qe={})),function(t){t[t.And=0]="And",t[t.Or=1]="Or"}(We||(We={})),qe.Equals,qe.NotEquals,qe.GreaterThan,qe.LessThan,We.And,We.Or;class Ze{schema;statement;constructor(t,e){this.schema=t,this.statement=e}getValue(t){let e=-1,s=!1,i=!1;for(let t=0;t<this.statement.length;t++){const r=this.statement[t];if(r==We.And||r==We.Or){e=r;continue}const o=this.schema.nodes[r[0]].getValue(this.schema.voxel.getState());switch(r[1]){case qe.Equals:i=o==r[2];break;case qe.NotEquals:i=o!=r[2];break;case qe.GreaterThan:i=o>=r[2];break;case qe.LessThan:i=o<=r[2]}if(-1!=e)switch(e){case We.And:s=s&&i;break;case We.Or:s=s||i}else s=i}return s}}class Ke{schema;tree;statements=[];constructor(t,e,s){this.schema=t,this.tree=s;for(const s of e)this.statements.push(new Ze(t,s))}getState(){if(!this.tree.length)return-1;let t=this.tree;for(let e=0;e<this.statements.length;e++)t=t[this.statements[e].getValue(this)?1:0];return t}}class Je{id;data;isModel=!0;geometries=[];modSchema;modTree;transparentIndex;baseInputMap;conditonalInputMap;schema;effects;shapeStateTree;condtioanlShapeStateTree;constructor(t,e,s){this.id=t,this.data=e,this.baseInputMap=s.baseGeometryInputMap,this.conditonalInputMap=s.condiotnalGeometryInputMap,this.transparentIndex=new Xe(s.transparentFaceIndex),this.modSchema=new He.X(s.modSchema),this.modTree=new Ye.z(this.modSchema,0,s.modStateTree),this.schema=new He.X(e.schema),this.shapeStateTree=new Ye.z(this.schema,0,e.shapeStateTree),this.condtioanlShapeStateTree=new Ke(this.schema,e.condiotnalStatements,e.condiotnalStateTree),this.effects=new $e(this)}getShapeStateTransaprentByteIndex(t,e){return this.data.relativeGeometryByteIndexMap[this.data.shapeStateRelativeGeometryMap[t][e]]}getCondtionalStateTransaprentByteIndex(t,e){return this.data.relativeGeometryByteIndexMap[this.data.condiotnalShapeStateRelativeGeometryMap[t][e]]}isShapeStateFaceTransparent(t,e,s,i){return 1==this.transparentIndex.getValue(t,this.getShapeStateTransaprentByteIndex(e,s),i)}isCondtionalStateFaceTransparent(t,e,s,i){return 1==this.transparentIndex.getValue(t,this.getCondtionalStateTransaprentByteIndex(e,s),i)}process(t){const e=yt.getHash(t.nVoxel,t.position.x,t.position.y,t.position.z),s=yt.space.stateCache[e],i=yt.space.modCache[e];if(void 0!==s&&s>-1){const r=this.data.shapeStateMap[s],o=this.data.shapeStateGeometryMap[s],n=r.length,a=this.baseInputMap[i][s];for(let s=0;s<n;s++){const i=a[r[s]],n=gt.geometry[o[s]],h=n.nodes.length;for(let s=0;s<h;s++)n.nodes[s].add(t,e,t.origin,i[s])}}const r=yt.space.conditonalStateCache[e];if(void 0!==r&&r>-1){const s=this.data.condiotnalShapeStateMap[r],o=s.length;for(let r=0;r<o;r++){const o=s[r],n=o.length,a=this.conditonalInputMap[i][r];for(let s=0;s<n;s++){const i=o[s],r=a[s],n=gt.geometry[this.data.geoLinkMap[i]],h=n.nodes.length;for(let s=0;s<h;s++)n.nodes[s].add(t,e,t.origin,r[s])}}}this.effects.addEffects(t.voxel.getState(),t.origin,t.effects),t.clearCalculatedData()}onTexturesRegistered(t){}}var ts=s(62348),es=s(24653),ss=s(26704),is=s(54186);const rs=t=>({section:t,palettes:{ids:new ts.h,level:new ts.h,light:new ts.h,state:new ts.h,mod:new ts.h,secondaryId:new ts.h,secondaryState:new ts.h},ids:new Uint16Array(t.ids.length),idsAllTheSame:!0,remappedIds:!1,light:new Uint16Array(t.light.length),lightAllTheSame:!0,isLightPaletted:!1,remappedLight:!1,level:new Uint8Array(t.level.length),levelAllTheSame:!0,isLevelPaletted:!1,remappedLevel:!1,state:new Uint16Array(t.state.length),stateAllTheSame:!0,isStatePaletted:!1,remappedState:!1,mod:new Uint16Array(t.mod.length),modAllTheSame:!0,isModPaletted:!1,remappedMod:!1,secondary:new Uint16Array(t.secondary.length),isSecondaryPaletted:!1,secondaryAllTheSame:!0,remappedSecondary:!1});let os,ns,as,hs;function ls(t,e){ns.setData(t.section.sectionState);const s={};return t.remappedIds&&(s.id=Uint16Array.from(t.palettes.ids._palette)),t.remappedLevel&&(s.level=Uint8Array.from(t.palettes.level._palette)),t.remappedLight&&(s.light=Uint16Array.from(t.palettes.light._palette)),t.remappedState&&(s.state=Uint16Array.from(t.palettes.state._palette)),t.remappedMod&&(s.mod=Uint16Array.from(t.palettes.mod._palette)),t.remappedSecondary&&(s.secondaryId=Uint16Array.from(t.palettes.secondaryId._palette),s.secondaryState=Uint16Array.from(t.palettes.secondaryState._palette)),{state:Object.values(ns.serialize()),palettes:s,buffers:{id:t.idsAllTheSame?t.ids[0]:(0,is.S)(t.remappedIds?t.palettes.ids.size:e.ids.size,t.ids),level:t.isLevelPaletted?t.level[0]:t.isLevelPaletted?(0,is.S)(t.remappedLevel?t.palettes.level.size:e.level.size,t.level):new Uint8Array(t.section.level.slice()),light:t.lightAllTheSame?t.light[0]:t.isLightPaletted?(0,is.S)(t.remappedLight?t.palettes.light.size:e.light.size,t.light):new Uint16Array(t.section.light.slice()),state:t.stateAllTheSame?t.state[0]:t.isStatePaletted?(0,is.S)(t.remappedState?t.palettes.state.size:e.state.size,t.state):new Uint16Array(t.section.state.slice()),mod:t.modAllTheSame?t.mod[0]:t.isModPaletted?(0,is.S)(t.remappedMod?t.palettes.mod.size:e.mod.size,t.mod):new Uint16Array(t.section.mod.slice()),secondary:t.secondaryAllTheSame?t.secondary[0]:t.isSecondaryPaletted?(0,is.S)(t.remappedSecondary?Math.max(t.palettes.secondaryState.size,t.palettes.secondaryId.size):Math.max(e.secondaryState.size,e.secondaryId.size),t.secondary):new Uint16Array(t.secondary)}}}function cs(t){const e=At._.sectors.get(t.location[0],t.location[1],t.location[2],t.location[3]);if(!e)throw new Error(`Column at location ${location} does not exist when trying to arhicve it.`);os||(os=Bt.hz.StateStruct.instantiate()),ns||(ns=Bt.wn.StateStruct.instantiate());const s={ids:new a.N,level:new ts.h,light:new ts.h,stateIdMap:[],state:new ts.h,modIdMap:[],mod:new ts.h,secondaryId:new a.N,secondaryState:new ts.h};os.setData(e.sectorState);const i=os.serialize(),r=[];for(const t of e.sections){const e=t.ids.length;let i=-1,o=-1,a=-1,h=-1,l=-1,c=-1;const d=rs(t);for(let r=0;r<e;r++){const e=n.O.ids.getStringId(t.ids[r]);es.E.setStringVoxel(e);const u=s.ids.isRegistered(e)?s.ids.getNumberId(e):s.ids.register(e);d.palettes.ids.isRegistered(u)||d.palettes.ids.register(u),-1==i&&(i=u);const f=1==es.E.instance[ss.y.canHaveSecondary]&&n.O.ids.getStringId(t.secondary[r]),g=f?s.secondaryId.isRegistered(f)?s.secondaryId.getNumberId(f):s.secondaryId.register(f):s.secondaryState.isRegistered(t.secondary[r])?s.secondaryState.getId(t.secondary[r]):s.secondaryState.register(t.secondary[r]);f?!d.palettes.secondaryId.isRegistered(g)&&d.palettes.secondaryId.register(g):!d.palettes.secondaryState.isRegistered(g)&&d.palettes.secondaryState.register(g),-1==c&&(c=t.secondary[r]);const p=s.level.isRegistered(t.level[r])?s.level.getId(t.level[r]):s.level.register(t.level[r]);d.palettes.level.isRegistered(t.level[r])||d.palettes.level.register(t.level[r]),-1==a&&(a=p);let m=-1;s.state.isRegistered(t.state[r])?m=s.state.getId(t.state[r]):(m=s.state.register(t.state[r]),s.stateIdMap[m]=f?t.secondary[r]:t.ids[r]),d.palettes.state.isRegistered(m)||d.palettes.state.register(m),-1==h&&(h=m);let v=-1;s.mod.isRegistered(t.mod[r])?v=s.mod.getId(t.mod[r]):(v=s.mod.register(t.mod[r]),s.stateIdMap[v]=f?t.secondary[r]:t.ids[r]),d.palettes.mod.isRegistered(v)||d.palettes.mod.register(v),-1==l&&(l=v);const y=s.light.isRegistered(t.light[r])?s.light.getId(t.light[r]):s.light.register(t.light[r]);d.palettes.light.isRegistered(t.light[r])||d.palettes.light.register(t.light[r]),-1==o&&(o=y),u!=i&&(d.idsAllTheSame=!1),p!=a&&(d.levelAllTheSame=!1),m!=h&&(d.stateAllTheSame=!1),v!=l&&(d.modAllTheSame=!1),y!=o&&(d.lightAllTheSame=!1),g!=c&&(d.secondaryAllTheSame=!1),d.ids[r]=u,d.level[r]=p,d.state[r]=m,d.mod[r]=v,d.secondary[r]=g,d.light[r]=y}r.push(d)}for(const t of r){const e=t.palettes.ids.size<s.ids.size&&t.palettes.ids.size<=255&&!t.idsAllTheSame,i=t.palettes.level.size<s.level.size&&t.palettes.level.size<=255&&!t.levelAllTheSame,r=t.palettes.state.size<s.state.size&&t.palettes.state.size<=255&&!t.stateAllTheSame,o=t.palettes.mod.size<s.mod.size&&t.palettes.mod.size<=255&&!t.modAllTheSame,n=t.palettes.light.size<s.light.size&&t.palettes.light.size<=255&&!t.lightAllTheSame,a=Math.max(t.palettes.secondaryId.size,t.palettes.secondaryState.size)<Math.max(s.secondaryState.size,s.secondaryId.size)&&Math.max(t.palettes.secondaryId.size,t.palettes.secondaryState.size)<=255&&!t.secondaryAllTheSame;if(t.isLightPaletted=s.light.size<65535&&t.palettes.light.size<255,t.isLevelPaletted=s.level.size<255&&t.palettes.level.size<255,t.isStatePaletted=s.state.size<65535&&t.palettes.state.size<255,t.isModPaletted=s.mod.size<65535&&t.palettes.mod.size<255,t.isSecondaryPaletted=s.secondaryState.size<65535&&t.palettes.secondaryState.size<255&&t.palettes.secondaryId.size<255,t.remappedIds=e,t.remappedLight=n&&t.isLightPaletted,t.remappedState=r&&t.isStatePaletted,t.remappedMod=o&&t.isModPaletted,t.remappedSecondary=a&&t.isSecondaryPaletted,!(e||n||a||r))continue;const h=t.section.ids.length;for(let l=0;l<h;l++)es.E.setVoxel(t.ids[l]),e&&(t.ids[l]=t.palettes.ids.getId(t.ids[l])),n&&(t.light[l]=t.palettes.light.getId(t.section.light[l])),i&&(t.level[l]=t.palettes.level.getId(t.section.level[l])),r&&(t.state[l]=t.palettes.state.getId(s.state.getId(t.section.state[l]))),o&&(t.mod[l]=t.palettes.mod.getId(s.mod.getId(t.section.mod[l]))),a&&(t.secondary[l]=1==es.E.instance[ss.y.canHaveSecondary]?t.palettes.secondaryId.getId(t.secondary[l]):t.palettes.secondaryState.getId(t.secondary[l]))}const o={};for(let t=0;t<s.state._palette.length;t++){const e=s.state._palette[t],i=n.O.ids.getStringId(s.stateIdMap[t]);if(!je.r.hasVoxelSchema(i))continue;const r=je.r.getVoxelSchemas(i);o[t]=r.state.getStateObject(e)}const h={};for(let t=0;t<s.mod._palette.length;t++){const e=s.mod._palette[t],i=n.O.ids.getStringId(s.modIdMap[t]);if(!je.r.hasVoxelSchema(i))continue;const r=je.r.getVoxelSchemas(i);h[t]=r.mod.getStateObject(e)}const l=[];for(const t of r)l.push(ls(t,s));const c={id:s.ids._palette,stateMap:o,modMap:h,state:new Uint16Array(s.state._palette),mod:new Uint16Array(s.mod._palette)};return s.light.size<255&&(c.light=new Uint16Array(s.light._palette)),s.level.size<255&&(c.level=new Uint8Array(s.level._palette)),s.light.size<255&&(c.light=new Uint16Array(s.light._palette)),s.secondaryId.size>0&&(c.secondaryId=s.secondaryId._palette),s.secondaryState.size<255&&(c.secondaryState=new Uint16Array(s.secondaryState._palette)),{version:"",location:[...t.location],sectorState:i,buffers:{},keys:{sectionState:[...ns.getKeys()]},palettes:c,sections:l}}const ds=(t,e)=>{(t.palettes.id.length<=15||e.palettes.id&&e.palettes.id.length<=15)&&ArrayBuffer.isView(e.buffers.id)&&(e.buffers.id=(0,is.f)(Math.min(e.palettes.id?.length||1/0,t.palettes.id?.length||0),e.buffers.id)),(e.palettes.light&&e.palettes.light.length<=15||t.palettes.light&&t.palettes.light.length<=15)&&ArrayBuffer.isView(e.buffers.light)&&(e.buffers.light=(0,is.f)(Math.min(e.palettes.light?.length||1/0,t.palettes.light?.length||0),e.buffers.light)),(e.palettes.state&&e.palettes.state.length<=15||t.palettes.state&&t.palettes.state.length<=15)&&ArrayBuffer.isView(e.buffers.state)&&(e.buffers.state=(0,is.f)(Math.min(e.palettes.state?.length||1/0,t.palettes.state?.length||0),e.buffers.state)),(e.palettes.mod&&e.palettes.mod.length<=15||t.palettes.mod&&t.palettes.mod.length<=15)&&ArrayBuffer.isView(e.buffers.mod)&&(e.buffers.mod=(0,is.f)(Math.min(e.palettes.mod?.length||1/0,t.palettes.mod?.length||0),e.buffers.mod)),(e.palettes.secondaryState&&e.palettes.secondaryState.length<=15||t.palettes.secondaryState&&t.palettes.secondaryState.length<=15)&&(e.palettes.secondaryId&&e.palettes.secondaryId.length<=15||t.palettes.secondaryId&&t.palettes.secondaryId.length<=15)&&ArrayBuffer.isView(e.buffers.secondary)&&(e.buffers.secondary=(0,is.f)(Math.max(Math.min(e.palettes.secondaryId?.length||1/0,t.palettes.secondaryId?.length||0),Math.min(e.palettes.secondaryState?.length||1/0,t.palettes.secondaryState?.length||0)),e.buffers.secondary))},us=t=>({sector:t,idPalette:new a.N(t.palettes.id),secondaryId:t.palettes.secondaryId?new a.N(t.palettes.secondaryId):void 0,lightPalette:t.palettes.light?new ts.h(t.palettes.light):void 0,statePalette:t.palettes.state?new ts.h(t.palettes.state):void 0,modPalette:t.palettes.mod?new ts.h(t.palettes.mod):void 0,secondaryState:t.palettes.secondaryState?new ts.h(t.palettes.secondaryState):void 0}),fs=t=>({section:t,idPalette:t.palettes.id?new ts.h(t.palettes.id):void 0,lightPalette:t.palettes.light?new ts.h(t.palettes.light):void 0,statePalette:t.palettes.state?new ts.h(t.palettes.state):void 0,modPalette:t.palettes.mod?new ts.h(t.palettes.mod):void 0,secondaryState:t.palettes.secondaryState?new ts.h(t.palettes.secondaryState):void 0,secondaryId:t.palettes.secondaryId?new ts.h(t.palettes.secondaryId):void 0}),gs=(t,e,s)=>s.section.buffers.state instanceof Uint16Array?t:"number"==typeof s.section.buffers.id?n.O.ids.getNumberId(e.sector.palettes.id[s.section.buffers.id]):s.idPalette?n.O.ids.getNumberId(e.idPalette.getStringId(s.idPalette.getValue(t))):n.O.ids.getNumberId(e.idPalette.getStringId(t)),ps=(t,e,s)=>s.section.buffers.light instanceof Uint16Array||"number"==typeof s.section.buffers.light?t:s.lightPalette?s.lightPalette.getValue(t):e.lightPalette?e.lightPalette.getValue(t):t,ms=(t,e,s,i,r)=>{const o=n.O.ids.getStringId(t);if(!je.r.hasVoxelSchema(o))return e;let a=-1;return(r.section.buffers.state instanceof Uint16Array||"number"==typeof r.section.buffers.state)&&(a=e),r.statePalette?a=r.statePalette.getValue(e):i.statePalette&&(a=e),void 0!==s[a]?s[a]:(e=je.r.getVoxelSchemas(o).state.fromStateObject(i.sector.palettes.stateMap[a]),s[a]=e,e)},vs=(t,e,s,i,r)=>{const o=n.O.ids.getStringId(t);if(!je.r.hasVoxelSchema(o))return e;let a=-1;return(r.section.buffers.state instanceof Uint16Array||"number"==typeof r.section.buffers.state)&&(a=e),r.modPalette?a=r.modPalette.getValue(e):i.modPalette&&(a=e),void 0!==s[a]?s[a]:(e=je.r.getVoxelSchemas(o).mod.fromStateObject(i.sector.palettes.modMap[a]),s[a]=e,e)},ys=(t,e,s,i)=>(es.E.setVoxel(t),1==es.E.instance[ss.y.canHaveSecondary]?"number"==typeof i.section.buffers.secondary?n.O.ids.getNumberId(s.sector.palettes.secondaryId[i.section.buffers.secondary]):i.secondaryId?n.O.ids.getNumberId(s.secondaryId.getStringId(i.secondaryId.getValue(e))):n.O.ids.getNumberId(s.sector.palettes.secondaryId[e]):"number"==typeof i.section.buffers.secondary?e:i.secondaryState&&s.secondaryState?s.secondaryState.getValue(i.secondaryState.getValue(e)):s.secondaryState?s.secondaryState.getId(e):e);function xs(t,e){as||(as=Bt.hz.StateStruct.instantiate()),hs||(hs=Bt.wn.StateStruct.instantiate());const s=new Bt.hz(Bt.hz.CreateNew());s.position[0]=t.location[1],s.position[1]=t.location[2],s.position[2]=t.location[3],e.loadColumnState?e.loadColumnState(t.sectorState,s):(as.setData(s.sectorState),as.deserialize(t.sectorState));const i=us(t),r={},o={};for(let n=0;n<t.sections.length;n++){const a=t.sections[n],h=fs(a),l=s.sections[n],c={};for(let e=0;e<t.keys.sectionState.length;e++)c[t.keys.sectionState[e]]=a.state[e];ds(t,a),e.loadSectionState?e.loadSectionState(t.keys.sectionState,a.state,l):(hs.setData(l.sectionState),hs.deserialize(c));for(let t=0;t<l.ids.length;t++){l.ids[t]=gs("number"==typeof a.buffers.id?a.buffers.id:a.buffers.id[t],i,h),l.light[t]=ps("number"==typeof a.buffers.light?a.buffers.light:a.buffers.light[t],i,h),l.secondary[t]=ys(l.ids[t],"number"==typeof a.buffers.secondary?a.buffers.secondary:a.buffers.secondary[t],i,h),es.E.setVoxel(l.ids[t]);let e=es.E.instance[ss.y.canHaveSecondary]&&l.secondary[t]>0;l.state[t]=ms(e?l.secondary[t]:l.ids[t],"number"==typeof a.buffers.state?a.buffers.state:a.buffers.state[t],r,i,h),l.mod[t]=vs(e?l.secondary[t]:l.ids[t],"number"==typeof a.buffers.mod?a.buffers.mod:a.buffers.mod[t],o,i,h)}s.sections[n]=l}return s}var As=s(54265);function bs(t){if(!At._.sectors.get(t[0],t[1],t[2],t[3]))throw new Error(`Sector at location ${t.toString()} does not exist`);const e=cs({location:t}),s=[];e.palettes.light&&s.push(e.palettes.light.buffer),e.palettes.state&&s.push(e.palettes.state.buffer),e.palettes.secondaryState&&s.push(e.palettes.secondaryState.buffer);for(const t of e.sections)"number"!=typeof t.buffers.id&&s.push(t.buffers.id.buffer),"number"!=typeof t.buffers.light&&s.push(t.buffers.light.buffer),"number"!=typeof t.buffers.state&&s.push(t.buffers.state.buffer),"number"!=typeof t.buffers.secondary&&s.push(t.buffers.secondary.buffer),"number"!=typeof t.buffers.mod&&s.push(t.buffers.mod.buffer),t.palettes.id&&s.push(t.palettes.id.buffer),t.palettes.light&&s.push(t.palettes.light.buffer),t.palettes.state&&s.push(t.palettes.state.buffer),t.palettes.mod&&s.push(t.palettes.mod.buffer),t.palettes.secondaryState&&s.push(t.palettes.secondaryState.buffer),t.palettes.secondaryId&&s.push(t.palettes.secondaryId.buffer);return[e,s]}async function ws(t={}){const e=new r.c;r.c.environment=xt.O.isNode()?"node":"browser";let s="render";"node"==r.c.environment&&(s="server"),await o.QK.init("constructor",self,s);let n=!1;var a,h;return yt.init(),(0,i.A)({onSync(t){!function(t,e){fe.register(t),gt.registerCustomNode("liquid",Qe),gt.setGeometryPalette(e.geometryPalette),gt.registerGeometry(e.geometry),gt.registerModels(e.models);for(const t of e.models)je.r.registerModel(t.id,t.schema);for(const t of e.voxels)je.r.registerVoxel(t.id,t.modelId,t.modSchema);Ge.B.load(e.tagState);for(const t of e.voxels)gt.registerVoxel(new Je(t.id,gt.modelData.get(t.modelId),t))}(t.voxels.materials.palette,t.voxels.models),n=!0}}),o.QK.registerTask("clear-all",(()=>{At._.clearAll()})),await new Promise((t=>{const e=()=>{if(n)return t(!0);setTimeout(e,10)};e()})),function(t){o.QK.registerTask("archive-sector",(async t=>bs(t))),o.QK.registerTask("archive-sector-binary",(async t=>{const[e]=bs(t),s=await async function(t){return await new Response(new Blob([As.f6.objectToBuffer(t)]).stream().pipeThrough(new CompressionStream("gzip"))).arrayBuffer()}(e);return[s,[s]]})),o.QK.registerTask("import-sector",(async e=>{const s=xs(e,{});await t.worldThread.runTaskAsync("load-sector",[e.location,s])})),o.QK.registerTask("import-sector-binary",(async([e,s])=>{const i=xs(await async function(t,e=!1){const s=await new Response(new Blob([t]).stream().pipeThrough(new DecompressionStream("gzip"))).arrayBuffer();As.f6.setUseSharedMemory(e);const i=As.f6.bufferToObject(s);return As.f6.setUseSharedMemory(!1),i}(s,!0),{});await t.worldThread.runTaskAsync("load-sector",[e,i])}))}({worldThread:e.threads.world}),o.QK.registerTask(Be.U.SyncDimension,(t=>{At._.dimensions.add(t.id)})),o.QK.registerTask(Be.U.UnSyncDimension,(t=>{})),o.QK.registerTask(Be.U.SyncSector,(t=>{At._.sectors.add(t[0][0],t[0][1],t[0][2],t[0][3],t[1])})),o.QK.registerTask(Be.U.UnSyncSector,(t=>{At._.sectors.remove(t[0],t[1],t[2],t[3])})),o.QK.registerTask(bt.z.Propagation,(async t=>{const e=new St.P;e.setOrigin(t),function(t){if(!wt.i.doLight())return!1;const e=At._.sectors.get(t.origin[0],t.origin[1],t.origin[2],t.origin[3]);if(!e)return console.error(`Tried running world rgb on a sector that does not exist ${t.origin.toString()}`),!1;let s=Et.k.section.bounds.x+e.position[0],i=Et.k.section.bounds.z+e.position[2];for(let r=0;r<e.sections.length;r++){const o=e.sections[r];if(!o)continue;te.setSection(o);let[n,a]=Ot.setSection(o).getMinMax();const h=e.position[0],l=e.position[1]+r*Et.k.section.bounds.y,c=e.position[2];if(Math.abs(n)!=1/0||Math.abs(a)!=1/0)for(let e=l+n;e<=l+a;e++)for(let r=h;r<s;r++)for(let s=c;s<i;s++){const i=te.getVoxel(r,e,s);i&&!i.isAir()&&i.isLightSource()&&t.rgb.update.push(r,e,s)}}(0,_t.D)(t)}(e)})),o.QK.registerTask(bt.z.Explosion,(async t=>{const e=t[0],s=Et.k.sector.getPosition(e[1],e[2],e[3]),i=new St.P;i.setOrigin([e[0],s.x,s.y,s.z]),$t.runExplosion(i,t[1])})),o.QK.registerTask(bt.z.WorldSun,(t=>{const e=Et.k.sector.getPosition(t[1],t[2],t[3]),s=new St.P;s.setOrigin([t[0],e.x,e.y,e.z]),function(t){const[e,s,i,r]=t.origin,o=Qt.getRelative(t.origin),n=Qt.getAbsolute(t.origin),a=s+Et.k.sector.bounds.x,h=Et.k.world.bounds.MaxY,l=r+Et.k.sector.bounds.z,c=t.nDataCursor.getSector(t.origin[1],t.origin[2],t.origin[3]);if(!c)return void console.warn("Could not load sector when running world sun at ",t.origin.toString());const d=n-1<0?0:n;for(let t=d;t<h;t++)for(let e=s;e<a;e++)for(let s=r;s<l;s++){const i=c.getVoxel(e,t,s);if(!i)continue;const r=i.getLight();r<0||i.setLight(Gt.setS(15,r))}const u=n==o?o+1:o;let f=jt.length;for(let e=d;e<=u;e++)for(let i=s;i<a;i++)for(let s=r;s<l;s++){const r=c.getVoxel(i,e,s)?.getLight();if(!(r&&r<0&&15!=Gt.getS(r)))for(let r=0;r<It.LE.length;r++){const o=It.LE[r],n=i+o[0],a=e+o[1],h=s+o[2],l=t.nDataCursor.getVoxel(n,a,h);if(!l)continue;const c=l.getLight();if(c>-1&&Gt.getS(c)<15){jt[f++]=i,jt[f++]=e,jt[f++]=s;break}}}for(;jt.length;){const e=jt.shift(),s=jt.shift(),i=jt.shift(),r=t.sDataCursor.getVoxel(e,s,i)?.getLight();if(!r||r<0)continue;for(let o=0;o<5;o++){const n=e+Wt[o][0],a=s+Wt[o][1],h=i+Wt[o][2],l=t.nDataCursor.getVoxel(n,a,h);if(l){const t=l.getLight();t>-1&&(0,qt.j4)(t,r)&&(jt.push(n),jt.push(a),jt.push(h),l.setLight((0,qt.ig)(r,t)))}}const o=t.nDataCursor.getVoxel(e,s-1,i);if(o){const t=o.getLight();t>-1&&(0,qt.jg)(t,r)&&(o.isAir()?(jt.push(e),jt.push(s-1),jt.push(i),o.setLight((0,qt.Kl)(r,t))):o.isOpaque()||(jt.push(e),jt.push(s-1),jt.push(i),o.setLight((0,qt.ig)(r,t))))}}}(s)})),a=e.threads.parent,o.QK.registerTask(bt.z.BuildSection,(t=>{const e=Te(t);e&&a.runTask("set-section",e[0],e[1])})),o.QK.registerTask(bt.z.BuildSector,(t=>{const e=Et.k.sector.getPosition(t[1],t[2],t[3]),s=At._.sectors.get(t[0],e.x,e.y,e.z);if(s)if(0!=s.sections.length)for(let e=0;e<s.sections.length;e++){if(!s.sections[e])continue;const i=Te([t[0],s.position[0],s.position[1]+e*Et.k.section.bounds.y,s.position[2]]);i&&a.runTask("set-section",i[0],i[1])}else console.warn("Tried building a sector with no sections.",s.position);else console.warn("Tried building a sector that does not exists.",[e.x,e.y,e.z])})),h={onDone(t){e.threads.world.runTask("build-queue",[t.origin[0],t.bounds.getSections()])}},o.QK.registerTask(bt.z.VoxelUpdate,(async t=>{const e=await Pt(t);e&&h.onDone(e)})),o.QK.registerTask(bt.z.VoxelErease,(async t=>{const e=await Dt(t);e&&h.onDone(e)})),o.QK.registerTask(bt.z.VoxelPaint,(async t=>{const e=await kt(t);e&&h.onDone(e)})),o.QK.registerTask(bt.z.Generate,(t=>new Promise((e=>Le.J.generate(t,"generate",e))))),o.QK.registerTask(bt.z.Decorate,(t=>new Promise((e=>Le.J.generate(t,"decorate",e))))),e}},50433:(t,e,s)=>{"use strict";s.d(e,{LE:()=>o,vY:()=>r});const i=[],r=[[0,0],[1,0],[0,1],[1,1],[-1,0],[0,-1],[-1,-1],[1,-1],[-1,1]],o=[[0,1,0],[0,-1,0],[1,0,0],[-1,0,0],[0,0,-1],[0,0,1]];for(let t=-1;t<2;t++)for(const e of r)i.push([e[0],t,e[1]])},64517:(t,e,s)=>{"use strict";s.d(e,{Hp:()=>u,Hx:()=>g,IH:()=>A,In:()=>f,Kl:()=>y,QT:()=>b,Zk:()=>w,ig:()=>x,j4:()=>m,jg:()=>v,pq:()=>p,tr:()=>I});let i=2;function r(t){return 15&t}function o(t){return(240&t)>>4}function n(t){return(3840&t)>>8}function a(t){return(61440&t)>>12}function h(t,e){return-16&e|t}function l(t,e){return-241&e|t<<4}function c(t,e){return-3841&e|t<<8}function d(t,e){return-61441&e|t<<12}function u(t,e){let s=o(t),i=n(t),r=a(t),h=o(e),l=n(e),c=a(e);return s<h||i<l||r<c}function f(t,e){let s=o(t)+2,i=n(t)+2,r=a(t)+2,h=o(e),l=n(e),c=a(e);return s<=h||i<=l||r<=c}function g(t,e){let s=o(t),i=n(t),r=a(t),h=o(e),l=n(e),c=a(e);return s>=h||i>=l||r>=c}function p(t,e){let s=r(e),i=o(t)-1;i<0&&(i=0);let u=o(e);i<u&&(i=u);let f=n(t)-1;f<0&&(f=0);let g=n(e);f<g&&(f=g);let p=a(t)-1;p<0&&(p=0);let m=a(e);p<m&&(p=m);let v=0;return v=h(s,v),v=l(i,v),v=c(f,v),v=d(p,v),v}function m(t,e){let s=r(t),o=r(e);return s+i<o}function v(t,e){let s=r(t),o=r(e);return 15==o?s<o:s+i<o}function y(t,e){let s=r(t),u=r(e);15==s&&(u=s),s<15&&(u=s-i);let f=o(e),g=n(e),p=a(e),m=0;return m=h(u,m),m=l(f,m),m=c(g,m),m=d(p,m),m}function x(t,e){let s=r(t)-i;s<0&&(s=0);let u=r(e);s<u&&(s=u);let f=o(e),g=n(e),p=a(e),m=0;return m=h(s,m),m=l(f,m),m=c(g,m),m=d(p,m),m}function A(t,e){return r(t)<r(e)}function b(t,e){return r(t)>=r(e)}function w(t,e){let s=r(e);return 15==s||r(t)<s}function I(t){return h(0,t)}},60445:(t,e,s)=>{"use strict";s.d(e,{D:()=>o,Q:()=>n});var i=s(50433),r=s(64517);function o(t){const e=t.rgb.update;for(;e.length;){const s=e.shift(),o=e.shift(),n=e.shift(),a=t.sDataCursor.getVoxel(s,o,n);if(!a)continue;const h=a.getLight();if(!(h<=0)){for(let a=0;a<6;a++){const l=i.LE[a][0]+s,c=i.LE[a][1]+o,d=i.LE[a][2]+n;if(!t.nDataCursor.inBounds(l,c,d))continue;const u=t.nDataCursor.getVoxel(l,c,d);if(!u)continue;const f=u.getLight();f>-1&&(0,r.In)(f,h)&&(e.push(l,c,d),u.setLight((0,r.pq)(h,f)))}t.bounds.update(s,o,n)}}}function n(t){const e=t.rgb.remove,s=t.rgb.update,o=t.rgb.removeMap,n=t.sun.updateMap;for(;e.length;){const a=e.shift(),h=e.shift(),l=e.shift();if(o.has(a,h,l))continue;o.add(a,h,l);const c=t.sDataCursor.getVoxel(a,h,l);if(!c)continue;const d=c.getLight();if(!(d<=0)){for(let o=0;o<6;o++){const c=i.LE[o][0]+a,u=i.LE[o][1]+h,f=i.LE[o][2]+l;if(!t.nDataCursor.inBounds(c,u,f))continue;const g=t.nDataCursor.getVoxel(c,u,f);if(!g)continue;const p=g.getLight(),m=g.hasRGBLight();m&&(0,r.Hp)(p,d)?(e.push(c,u,f),g.isLightSource()&&s.push(c,u,f)):m&&(0,r.Hx)(p,d)&&!n.has(c,u,f)&&(n.add(c,u,f),s.push(c,u,f))}t.bounds.update(a,h,l),c.setLight((0,r.tr)(d))}}o.clear()}},5268:(t,e,s)=>{"use strict";s.d(e,{a:()=>o,z:()=>n});var i=s(64517);const r=[[1,0,0],[-1,0,0],[0,0,1],[0,0,-1],[0,1,0]];function o(t){const e=t.sun.update;for(;e.length;){const s=e.shift(),o=e.shift(),n=e.shift(),a=t.sDataCursor.getVoxel(s,o,n);if(!a)continue;const h=a.getLight();if(!(h<=0)){for(let a=0;a<5;a++){const l=r[a][0]+s,c=r[a][1]+o,d=r[a][2]+n;if(!t.nDataCursor.inBounds(l,c,d))continue;const u=t.nDataCursor.getVoxel(l,c,d);if(u){const t=u.getLight();t>-1&&(0,i.j4)(t,h)&&(e.push(l,c,d),u.setLight((0,i.ig)(h,t)))}}if(t.nDataCursor.inBounds(s,o-1,n)){const r=t.nDataCursor.getVoxel(s,o-1,n);if(r){const t=r.getLight();t>-1&&(0,i.jg)(t,h)&&(r.isAir()?(e.push(s,o-1,n),r.setLight((0,i.Kl)(h,t))):r.isOpaque()||(e.push(s,o-1,n),r.setLight((0,i.ig)(h,t))))}}t.bounds.update(s,o,n)}}}function n(t,e=!0){const s=t.sun.remove,o=t.sun.update,n=t.sun.removeMap,a=t.sun.updateMap;for(;s.length;){const e=s.shift(),h=s.shift(),l=s.shift();if(n.has(e,h,l))continue;n.add(e,h,l);const c=t.sDataCursor.getVoxel(e,h,l);if(!c)continue;const d=c.getLight();if(!(d<=0)){for(let n=0;n<5;n++){const c=r[n][0]+e,u=r[n][1]+h,f=r[n][2]+l;if(!t.nDataCursor.inBounds(c,u,f))continue;const g=t.nDataCursor.getVoxel(c,u,f);if(g){const t=g.getLight();t>0&&((0,i.IH)(t,d)?s.push(c,u,f):(0,i.QT)(t,d)&&!a.has(c,u,f)&&(a.add(c,u,f),o.push(c,u,f)))}}if(t.nDataCursor.inBounds(e,h-1,l)){const r=t.nDataCursor.getVoxel(e,h-1,l);if(r){const t=r.getLight();t>0&&((0,i.Zk)(t,d)?s.push(e,h-1,l):(0,i.QT)(t,d)&&!a.has(e,h-1,l)&&(a.add(e,h-1,l),o.push(e,h-1,l)))}}t.bounds.update(e,h,l),c.setLight((0,i.tr)(d))}}n.clear()}},91704:(t,e,s)=>{"use strict";s.d(e,{P:()=>d});var i=s(75025),r=s(99638),o=s(95027);class n{_map=[];get size(){return this._map.length}origin=r.Az.Create();start(t,e,s){this._map.length=0,this.origin.x=t,this.origin.y=e,this.origin.z=s}has(t,e,s){return void 0!==this._map[r.Az.HashXYZ(t-this.origin.x,e-this.origin.y,s-this.origin.z)]}add(t,e,s){this._map[r.Az.HashXYZ(t-this.origin.x,e-this.origin.y,s-this.origin.z)]=!0}delete(t,e,s){this._map[r.Az.HashXYZ(t-this.origin.x,e-this.origin.y,s-this.origin.z)]=void 0}clear(){this._map.length=0}}const a=r.Az.Create(-1/0,-1/0,-1/0),h=r.Az.Create(1/0,1/0,1/0),l=r.Az.Create();class c{_task;min=r.Az.Clone(h);max=r.Az.Clone(a);constructor(t){this._task=t}reset(){r.Az.Copy(this.min,h),r.Az.Copy(this.max,a)}update(t,e,s){t<this.min.x&&(this.min.x=t),e<this.min.y&&(this.min.y=e),s<this.min.z&&(this.min.z=s),t>this.max.x&&(this.max.x=t),e>this.max.y&&(this.max.y=e),s>this.max.z&&(this.max.z=s)}getSections(){const t=o.k.section.getPosition(this.min.x-1,this.min.y-1,this.min.z-1,l),e=t.x,s=t.y,i=t.z,r=o.k.section.getPosition(this.max.x+1,this.max.y+1,this.max.z+1,l),n=r.x,a=r.y,h=r.z,c=[];for(let t=e;t<=n;t+=o.k.section.bounds.x)for(let e=s;e<=a;e+=o.k.section.bounds.y)for(let s=i;s<=h;s+=o.k.section.bounds.z)this._task.nDataCursor.inBounds(t,e,s)&&c.push([t,e,s]);return c}}class d{flow=new u;rgb=new f;sun=new f;bounds=new c(this);sDataCursor=new i.p;nDataCursor=new i.p;origin;setOrigin(t){this.sDataCursor.setFocalPoint(...t),this.nDataCursor.setFocalPoint(...t),this.origin=t,this.rgb.removeMap.start(t[1],t[2],t[3]),this.sun.removeMap.start(t[1],t[2],t[3]),this.rgb.updateMap.start(t[1],t[2],t[3]),this.sun.updateMap.start(t[1],t[2],t[3]),this.flow.update.map.start(t[1],t[2],t[3]),this.flow.remove.map.start(t[1],t[2],t[3]),this.flow.remove.noRemoveMap.start(t[1],t[2],t[3]),this.clear()}clear(){this.rgb.clear(),this.sun.clear(),this.flow.clear(),this.bounds.reset()}}class u{update={queue:[],map:new n};remove={queue:[],map:new n,noRemoveMap:new n};clear(){this.update.queue.length=0,this.update.map.clear(),this.remove.queue.length=0,this.remove.map.clear(),this.remove.noRemoveMap.clear()}}class f{update=[];remove=[];removeMap=new n;updateMap=new n;clear(){this.update.length=0,this.remove.length=0,this.removeMap.clear(),this.updateMap.clear()}}},98261:(t,e,s)=>{"use strict";s.d(e,{T:()=>u});var i=s(65350),r=s(67768),o=s(3338),n=s(3649),a=s(98899),h=s(91704),l=s(60445),c=s(5268);const d=new o.$;class u extends r.l{constructor(){super(),n.J._brushes.push(this)}requestsId;tasks=new h.P;start(t,e,s,i){return this.dataCursor.setFocalPoint(t,e,s,i),this.tasks.setOrigin([t,e,s,i]),this.dimension=t,this.x=e,this.y=s,this.z=i,this}paint(){let t=this.dataCursor.getVoxel(this.x,this.y,this.z);if(!t){if(""!=this.requestsId)return i.o.addToRequest(this.requestsId,[this.dimension,this.x,this.y,this.z],this.voxelCursor.getRaw()),this;throw new Error(`Tried painting in an unloaded location ${[this.dimension,this.x,this.y,this.z].toString()}`)}const e=t.getLight();return(e>0||!t.isAir())&&(this._erase(),t.setLight(e<0?0:e),d.hasRGBLight(e)&&(this.tasks.rgb.remove.push(this.x,this.y,this.z),(0,l.Q)(this.tasks)),d.hasSunLight(e)&&(this.tasks.sun.remove.push(this.x,this.y,this.z),(0,c.z)(this.tasks))),this._paint(),this.tasks.bounds.update(this.x,this.y,this.z),this}getUpdatedSections(){const t=this.tasks.bounds.getSections();return this.tasks.bounds.reset(),t}update(){let t=this.dataCursor.getVoxel(this.x,this.y,this.z);if(!t)return!1;const e=t.getLight();d.hasRGBLight(e)&&this.tasks.rgb.update.push(this.x,this.y,this.z),d.hasSunLight(e)&&this.tasks.sun.update.push(this.x,this.y,this.z),this.tasks.bounds.update(this.x,this.y,this.z)}erase(){let t=this.dataCursor.getVoxel(this.x,this.y,this.z);if(!t)return this;const e=t.getLight();return this._erase(),t=this.dataCursor.getVoxel(this.x,this.y,this.z),t.setLight(e>0?e:0),d.hasRGBLight(e)&&(this.tasks.rgb.remove.push(this.x,this.y,this.z),(0,l.Q)(this.tasks)),d.hasSunLight(e)&&(this.tasks.sun.remove.push(this.x,this.y,this.z),(0,c.z)(this.tasks)),this.tasks.bounds.update(this.x,this.y,this.z),this}runUpdates(){(0,l.D)(this.tasks),(0,c.a)(this.tasks),this.tasks.rgb.removeMap.clear(),this.tasks.sun.removeMap.clear()}worldAlloc(t,e){return a.c.instance.threads.world.runTaskAsync("world-alloc",[this.dimension,t,e])}worldDealloc(t,e){return a.c.instance.threads.world.runTaskAsync("world-dealloc",[this.dimension,t,e])}}},65350:(t,e,s)=>{"use strict";s.d(e,{o:()=>h});var i=s(95027),r=s(67768),o=s(98899),n=s(33329);const a=new r.l;a.voxelCursor;class h{static MAX_ATTEMPTS=100;static _requests=new Map;static registerRequest(t){const e=t.toString();return this._requests.set(e,{attempts:0,sections:new Map,dimension:t[0],voxels:[]}),e}static addToRequest(t,e,s){if(e[2]<i.k.world.bounds.MinY||e[2]>=i.k.world.bounds.MaxY)return!1;const r=this._requests.get(t);if(!r)return;if(!n._.sectors.get(e[0],e[1],e[2],e[3])){const t=i.k.sector.getPosition(e[1],e[2],e[3]),s=i.k.hash.hashVec3(t);r.sections.has(s)||(o.c.instance.threads.world.runTask("add-sector",[r.dimension,t.x,t.y,t.z]),r.sections.set(s,[t.x,t.y,t.z]))}const[a,h,l,c]=e;r.voxels.push([h,l,c,s])}static attemptRequestFullFill(t){const e=this._requests.get(t);if(!e||!e.voxels.length)return!0;let s=!0;for(const[t,r]of e.sections)i.k.world.inBounds(r[0],r[1],r[2])&&(n._.sectors.get(e.dimension,r[0],r[1],r[2])||(s=!1,o.c.instance.threads.world.runTask("add-sector",[e.dimension,r[0],r[1],r[2]])));return s?(a.stop(),this._requests.delete(t),!0):(e.attempts++,e.attempts>=this.MAX_ATTEMPTS&&(console.error("World gen requests cancled after max attempts",e),this._requests.delete(t),!0))}}},3649:(t,e,s)=>{"use strict";s.d(e,{J:()=>o});var i=s(65350),r=s(98261);class o{static worldGen=null;static register=i.o;static _brushes=[];static setWorldGen(t){this.worldGen=t}static async generate(t,e,s){if(!this.worldGen)throw new Error("A World Generator must be set.");const r=i.o.registerRequest(t[0]);for(const t of this._brushes)t.requestsId=r;if("generate"==e&&await this.worldGen.generate(t),"decorate"==e&&await this.worldGen.decorate(t),i.o.attemptRequestFullFill(r))s();else{const t=()=>{i.o.attemptRequestFullFill(r)?s():setTimeout(t,10)};t()}}static getBrush(){return new r.T}}},62348:(t,e,s)=>{"use strict";s.d(e,{h:()=>i});class i{_count=0;_palette=[];_map={};get size(){return this._count}constructor(t){if(t){let e=t.length;for(let s=0;s<e;s++)this.register(t[s])}}register(t){const e=this._count;return this._palette[e]=t,this._map[t]=e,this._count++,e}get(){return this._palette}getMap(){return this._map}isRegistered(t){return void 0!==this._map[t]}getId(t){return this._map[t]}getValue(t){return this._palette[t]}}},47464:(t,e,s)=>{"use strict";s.d(e,{hz:()=>r.h,pM:()=>o.p,wn:()=>i.w});var i=s(44575),r=s(38717),o=s(75025)},6624:(t,e,s)=>{"use strict";function i(){}s.d(e,{A:()=>i})},62158:(t,e,s)=>{"use strict";s.d(e,{A:()=>g});var i=s(83051),r=s(3649),o=s(99638),n=s(46300),a=s(62348),h=s(22879),l=s(24653),c=s(26704),d=s(54186);class u{index=o.F$.GetXZYOrder();size;ids;level;state;mod;secondary;idPalette;levelPalette;statePalette;modPalette;secondaryIdPalette;secondaryStatePalette;constructor(t){this.size=[...t.size],this.index.setBounds(...t.size),this.idPalette=new n.N(t.palettes.id),this.levelPalette=new a.h(t.palettes.level),this.statePalette=new a.h(t.palettes.state),this.modPalette=new a.h(t.palettes.mod),this.secondaryIdPalette=new n.N(t.palettes.secondaryId),this.secondaryStatePalette=new a.h(t.palettes.secondaryState),"object"==typeof t.buffers.ids?this.ids=(0,d.f)(t.palettes.id.length,t.buffers.ids):this.ids=t.buffers.ids,"object"==typeof t.buffers.level?this.level=(0,d.f)(t.palettes.level.length,t.buffers.level):this.level=t.buffers.level,"object"==typeof t.buffers.state?this.state=(0,d.f)(t.palettes.state.length,t.buffers.state):this.state=t.buffers.state,"object"==typeof t.buffers.mod?this.mod=(0,d.f)(t.palettes.mod.length,t.buffers.mod):this.mod=t.buffers.mod,"object"==typeof t.buffers.secondary?this.secondary=(0,d.f)(Math.max(t.palettes.secondaryState.length,t.palettes.secondaryId.length),t.buffers.secondary):this.secondary=t.buffers.secondary}getIndex(t,e,s){return this.index.getIndexXYZ(t,e,s)}getId(t){const e=this.ids;return h.O.ids.getNumberId(this.idPalette.getStringId("number"==typeof e?e:e[t]))}getState(t){const e=this.state;return this.statePalette.getValue("number"==typeof e?e:e[t])}getLevel(t){const e=this.mod;return this.modPalette.getValue("number"==typeof e?e:e[t])}getMod(t){const e=this.mod;return this.modPalette.getValue("number"==typeof e?e:e[t])}getSecondary(t,e){const s=this.secondary;return l.E.setVoxel(t),1==l.E.instance[c.y.canHaveSecondary]?h.O.ids.getNumberId(this.secondaryIdPalette.getStringId("number"==typeof s?s:s[e])):this.secondaryStatePalette.getValue("number"==typeof s?s:s[e])}*traverse(){const t=this.size,e=[0,0,0,0,0,0],s={position:[0,0,0],raw:e};for(const{x:i,y:r,z:n}of o.l5.FromToVec3([0,0,0],[t[0]-1,t[1]-1,t[2]-1],1)){const t=this.index.getIndexXYZ(i,r,n);s.position[0]=i,s.position[1]=r,s.position[2]=n,e[0]=this.getId(t),e[1]=0,e[2]=this.getLevel(t),e[3]=this.getState(t),e[4]=this.getMod(t),e[5]=this.getSecondary(e[0],t),e[0]<1&&e[3]<1||(yield s)}}toJSON(){return{templatorVersion:0,version:0,size:this.size,palettes:{id:this.idPalette._palette,level:Uint8Array.from(this.statePalette._palette),state:Uint16Array.from(this.statePalette._palette),mod:Uint16Array.from(this.modPalette._palette),secondaryId:this.secondaryIdPalette._palette,secondaryState:Uint16Array.from(this.secondaryStatePalette._palette)},buffers:{ids:this.ids instanceof Uint16Array||this.ids instanceof Uint8Array||"number"==typeof this.ids?this.ids:new Uint8Array(this.ids.buffer),level:this.level instanceof Uint8Array||"number"==typeof this.level?this.level:new Uint8Array(this.level.buffer),mod:this.mod instanceof Uint16Array||this.mod instanceof Uint8Array||"number"==typeof this.mod?this.mod:new Uint8Array(this.mod.buffer),state:this.state instanceof Uint16Array||this.state instanceof Uint8Array||"number"==typeof this.state?this.state:new Uint8Array(this.state.buffer),secondary:this.secondary instanceof Uint16Array||this.secondary instanceof Uint8Array||"number"==typeof this.secondary?this.secondary:new Uint8Array(this.secondary.buffer)}}}}var f=s(25701);function g(){const t=r.J.getBrush();f.QK.registerTask(i.m.PlaceVoxelArea,(async([e,[s,i,r],[o,n,a],h])=>{t.start(e,s,i,r),t.setData(h);for(let e=s;e<o;e++)for(let s=i;s<n;s++)for(let i=r;i<a;i++)t.dataCursor.inBounds(e,s,i)&&t.setXYZ(e,s,i).paint();t.runUpdates();for(let e=s;e<o;e++)for(let s=i;s<n;s++)for(let i=r;i<a;i++)t.dataCursor.inBounds(e,s,i)&&t.setXYZ(e,s,i).update();t.runUpdates();const l=t.getUpdatedSections();return t.stop(),[l]})),f.QK.registerTask(i.m.RemoveVoxelArea,(([e,[s,i,r],[o,n,a]])=>{t.start(e,s,i,r);for(let e=s;e<o;e++)for(let s=i;s<n;s++)for(let i=r;i<a;i++)t.dataCursor.inBounds(e,s,i)&&t.dataCursor.getVoxel(e,s,i)?.isRenderable()&&t.setXYZ(e,s,i).erase();t.runUpdates(),i-=1,r-=1,o+=1,n+=1,a+=1;for(let e=s-=1;e<o;e++)for(let s=i;s<n;s++)for(let i=r;i<a;i++)t.dataCursor.inBounds(e,s,i)&&t.setXYZ(e,s,i).update();t.runUpdates();const h=t.getUpdatedSections();return t.stop(),[h]})),f.QK.registerTask(i.m.BuildTemplate,(async([e,[s,i,r],o],n)=>{t.start(e,s,i,r);const a=new u(o),h=s+a.size[0],l=i+a.size[1],c=r+a.size[2];await t.worldAlloc([s,i,r],[h,l,c]);for(const{raw:e,position:o}of a.traverse())e[1]=0,t.setRaw(e).setXYZ(o[0]+s,o[1]+i,o[2]+r).paint();t.runUpdates();for(let e=s;e<h;e++)for(let s=i;s<l;s++)for(let i=r;i<c;i++)t.dataCursor.inBounds(e,s,i)&&t.setXYZ(e,s,i).update();t.runUpdates();const d=t.getUpdatedSections();return t.stop(),await t.worldDealloc([s,i,r],[h,l,c]),[d]}))}},84627:(t,e,s)=>{"use strict";s.d(e,{Cf:()=>u,fu:()=>d});const i=Math.sqrt(3),r=.5*(i-1),o=(3-i)/6,n=1/3,a=1/6,h=t=>0|Math.floor(t),l=new Float64Array([1,1,-1,1,1,-1,-1,-1,1,0,-1,0,1,0,-1,0,0,1,0,-1,0,1,0,-1]),c=new Float64Array([1,1,0,-1,1,0,1,-1,0,-1,-1,0,1,0,1,-1,0,1,1,0,-1,-1,0,-1,0,1,1,0,-1,1,0,1,-1,0,-1,-1]);function d(t=Math.random){const e=f(t),s=new Float64Array(e).map((t=>l[t%12*2])),i=new Float64Array(e).map((t=>l[t%12*2+1]));return function(t,n){let a=0,l=0,c=0;const d=(t+n)*r,u=h(t+d),f=h(n+d),g=(u+f)*o,p=t-(u-g),m=n-(f-g);let v,y;p>m?(v=1,y=0):(v=0,y=1);const x=p-v+o,A=m-y+o,b=p-1+2*o,w=m-1+2*o,I=255&u,S=255&f;let T=.5-p*p-m*m;if(T>=0){const t=I+e[S];T*=T,a=T*T*(s[t]*p+i[t]*m)}let _=.5-x*x-A*A;if(_>=0){const t=I+v+e[S+y];_*=_,l=_*_*(s[t]*x+i[t]*A)}let z=.5-b*b-w*w;if(z>=0){const t=I+1+e[S+1];z*=z,c=z*z*(s[t]*b+i[t]*w)}return 70*(a+l+c)}}function u(t=Math.random){const e=f(t),s=new Float64Array(e).map((t=>c[t%12*3])),i=new Float64Array(e).map((t=>c[t%12*3+1])),r=new Float64Array(e).map((t=>c[t%12*3+2]));return function(t,o,l){let c,d,u,f;const g=(t+o+l)*n,p=h(t+g),m=h(o+g),v=h(l+g),y=(p+m+v)*a,x=t-(p-y),A=o-(m-y),b=l-(v-y);let w,I,S,T,_,z;x>=A?A>=b?(w=1,I=0,S=0,T=1,_=1,z=0):x>=b?(w=1,I=0,S=0,T=1,_=0,z=1):(w=0,I=0,S=1,T=1,_=0,z=1):A<b?(w=0,I=0,S=1,T=0,_=1,z=1):x<b?(w=0,I=1,S=0,T=0,_=1,z=1):(w=0,I=1,S=0,T=1,_=1,z=0);const L=x-w+a,B=A-I+a,C=b-S+a,R=x-T+2*a,U=A-_+2*a,V=b-z+2*a,M=x-1+3*a,D=A-1+3*a,k=b-1+3*a,P=255&p,E=255&m,N=255&v;let F=.6-x*x-A*A-b*b;if(F<0)c=0;else{const t=P+e[E+e[N]];F*=F,c=F*F*(s[t]*x+i[t]*A+r[t]*b)}let O=.6-L*L-B*B-C*C;if(O<0)d=0;else{const t=P+w+e[E+I+e[N+S]];O*=O,d=O*O*(s[t]*L+i[t]*B+r[t]*C)}let Q=.6-R*R-U*U-V*V;if(Q<0)u=0;else{const t=P+T+e[E+_+e[N+z]];Q*=Q,u=Q*Q*(s[t]*R+i[t]*U+r[t]*V)}let q=.6-M*M-D*D-k*k;if(q<0)f=0;else{const t=P+1+e[E+1+e[N+1]];q*=q,f=q*q*(s[t]*M+i[t]*D+r[t]*k)}return 32*(c+d+u+f)}}function f(t){const e=new Uint8Array(512);for(let t=0;t<256;t++)e[t]=t;for(let s=0;s<255;s++){const i=s+~~(t()*(256-s)),r=e[s];e[s]=e[i],e[i]=r}for(let t=256;t<512;t++)e[t]=e[t-256];return e}}}]);